<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>听说 - 世界很大，风住过这里</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="听说 - 世界很大，风住过这里">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="听说 - 世界很大，风住过这里">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="听说 - 世界很大，风住过这里" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">听说 - 世界很大，风住过这里</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-articles/长大" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/f18e40a8/" class="article-date">
  <time class="dt-published" datetime="2018-04-05T20:52:00.000Z" itemprop="datePublished">2018-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/article/">article</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/f18e40a8/">长大</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>翻了翻过去的老照片，感慨很久没有拍过自己的照片了，时光在触摸屏的指尖一点点流逝。</p>
<p>清明时节，心情很丧。</p>
<p>想起了在学校打别人，又被别人打的荒诞而又快乐的时光。</p>
<p>想起了晚自习放学后，会偷偷跑到那个女孩家的楼梯道里，听她家里放电视剧的夜晚。</p>
<p>想起了那个在另一座城市读的学校，那些终日沉迷网络的日子，还有那些已经断了联系的人。</p>
<p>想起了那个不知天高地厚的自己，狠狠的栽了个跟头的夜晚；在窗户边望着窗外车水马龙，心酸饮泪。</p>
<p>想起了哪些很照顾年轻的我的兄弟，如果各奔前程，四方天涯。</p>
<p>想起了曾经那对，我真心祝福的情侣。最终却只能看着你们分开，各自成家。</p>
<p>想起了曾经落魄的自己，在寒冷的晚秋暮雨里，睡的公园的草地上，不知未来在哪里。</p>
<p>想起了那段被所有人否定的日子，负能量满满，莫名的倔强撑着抑郁的我一步一步坚强的走下去。</p>
<p>想起了那个被遗弃的炎炎夏日，徒步走了 12 个小时，从一座城市到另一座城市，眼泪流到干枯，走到日黑交替，心如死灰，蜷缩在网吧的椅子上，自己舔着伤口。</p>
<p>想起了那些麻木的日子，时光虚度，熬夜成瘾。</p>
<p>想起了那个改变自己的绝心，在所有人的反对声中坚定自己的每一步，拼搏而努力。感谢那个陌生人告诉我 “你一定可以！”，坚定我的绝心。今天我想回头对你说，我正在朝着自己的方向走去，而且做的很好。</p>
<p>想起了第一次辞职，夜不能寐，酝酿几日的辞职信息发给老板。</p>
<p>想起了那些熬夜拼搏的日子， 为了让自己更加优秀而战斗力激昂。</p>
<p>想起了那个初入职场的小子，忐忑而懵懂，什么都不知所措，试着用加班来掩饰自己的不足。</p>
<p>想起了初次见到她的样子，我的心里从此多了份牵挂。</p>
<p>想起了后来我们在一起的日子，从无到有，一点点组成一个家。</p>
<p>想起了我和她走过的每一条路，她的每一句支持。</p>
<p>想起了逐渐老去的父母。</p>
<p>许多年前，在我出门前，奶奶带着我去买了个行李箱，跟我说买个好点儿的，能多用些时间。时光让箱子一点点被塞满，衣服一件件的穿不下，丢掉，然后添置上新的。</p>
<p>后来我又换了更大的行李箱。</p>
<p>后来我们又换两个更大的行李箱。</p>
<p>后来我们搬家的时候已经需要搬家公司的那辆大货车。</p>
<p>这些年经历了太多的事情，有辛酸，有奋斗，有沮丧，有幸福，有失落，有争吵，有陪伴。</p>
<p>我们从一颗风雨中飘摇的小草，逐渐长成了一颗树。</p>
<p>最终我们成为了自己梦想中想要成为的那个样子么？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/f18e40a8/" data-id="cloizszvd004cxww6bwd6cq3t" data-title="长大" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/Node-js部署免费-自动续订HTTPS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/4f3c3fec/" class="article-date">
  <time class="dt-published" datetime="2018-03-14T07:09:00.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/4f3c3fec/">Node.js 部署免费/自动续订 HTTPS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>随着互联网快速发展，互联网信息安全越来越受到大家重视，<code>HTTPS</code> 应该是近两年各大厂商都在尽力普及的技术之一。国内大厂基本上已经全面普及了 HTTPS。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<h2 id="HTTPS-现状"><a href="#HTTPS-现状" class="headerlink" title="HTTPS 现状"></a>HTTPS 现状</h2><p>早在 2016 年底，我就写过 《 <a target="_blank" rel="noopener" href="https://tasaid.com/blog/20161003001126.html">从 HTTP 到 HTTPS 系列</a> 》文章来讲解 <code>HTTPS</code>。当时结合本站的部署经验，给大家详细介绍了 《 <a target="_blank" rel="noopener" href="https://tasaid.com/Blog/20161005024923.html">IIS 部署免费 HTTPS</a> 》。</p>
<p>这篇文章就跟大家介绍一下 <code>Node.js</code> 如何部署免费 <code>HTTPS</code> 以及简单的部署 <code>HTTP/2</code>。</p>
<p>截止 2018 年 03 月 13 日，由 <a target="_blank" rel="noopener" href="https://letsencrypt.org/stats/">Let’s Encrypt 实时统计报告</a> 显示，在统计的 6930 多万活跃网站中，已经有 5350 万（约 77%）的站点部署了 <code>HTTPS</code> 证书服务。</p>
<p><img src="//static.tasaid.com/blogs/91192a101e2d0a8e0c3ed72419bae957.png" alt="lets encrypt stats"></p>
<p>同时 <a target="_blank" rel="noopener" href="https://transparencyreport.google.com/https/overview">Google 透明度报告 - 网络上的 HTTPS 加密</a> 中，统计了使用 Chrome 浏览器，访问的站点统计中，HTTPS 使用率的增长情况：</p>
<p><img src="//static.tasaid.com/blogs/8217d50d1f9d089a16973dfe8851e1c0.png" alt="google stats"></p>
<p>而在今年 2 月份，Chrome 团队也<a target="_blank" rel="noopener" href="https://blog.chromium.org/2018/02/a-secure-web-is-here-to-stay.html">宣布</a>，将在 2018 年 7 月份发布的 Chrome 68 中，将没有部署 HTTPS 的网站标记为 “不安全”。</p>
<p><img src="//static.tasaid.com/blogs/38da874f165cb7326fdd3653eee3f202.png" alt="chrome 68 status"></p>
<p>简而言之，HTTPS 大势所趋。</p>
<h2 id="Node-js-部署-HTTPS"><a href="#Node-js-部署-HTTPS" class="headerlink" title="Node.js 部署 HTTPS"></a>Node.js 部署 HTTPS</h2><p>早在 《 <a target="_blank" rel="noopener" href="https://tasaid.com/Blog/20161005024923.html">从 HTTP 到 HTTPS - IIS 部署免费 HTTPS</a> 》一文中，我就指出了 <a target="_blank" rel="noopener" href="https://letsencrypt.org/">Let’s Encrypt</a> 免费证书的优势：</p>
<blockquote>
<p>由 ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，免费、访问速度快，稳定等。</p>
</blockquote>
<p>所以这次部署的证书也是围绕 <code>Let&#39;s Encrypt</code> 展开。</p>
<h3 id="greenlock-express"><a href="#greenlock-express" class="headerlink" title="greenlock-express"></a>greenlock-express</h3><p>由于 js 生态圈的繁华，所以想找一个现有的包是件很轻松的事情，<a target="_blank" rel="noopener" href="https://github.com/Daplie/greenlock-express">greenlock-express</a> 这个包就帮助我们封装了 <code>Let&#39;s Enctrypt</code> 证书的部署，只需要引入这个包并使用，就可以：</p>
<ol>
<li>自动注册 <code>Let&#39;s Encrypt</code> 证书</li>
<li>自动续订( 80 天左右)，且服务器无需重启</li>
<li>支持虚拟主机</li>
</ol>
<p>并且 <code>greenlock</code> 相关的证书生态圈十分完善，同样有支持 <code>koa</code> 的 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/greenlock-koa">greenlock-koa</a>。</p>
<p>注意：<code>greenlock-express</code> 在 <code>2.1.1</code> 之后开始支持由 Let’s Encrypt 2018 年开始发布的  ACME v2 协议证书。</p>
<p>从 2.1.1 之前升级上来的 <code>greenlock-express</code> 会有 API 变动，如果直接升级会报证书错误：</p>
<blockquote>
<p>Let’s Encrypt v1 is deprecated.<br>Please update to Let’s Encrypt v2 (ACME draft 12)</p>
</blockquote>
<p>如果想要继续使用 v1的证书服务，请先安装包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save le-acme-core</span><br></pre></td></tr></table></figure>

<p>然后修改以下代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;greenlock-express&#x27;</span>).<span class="title function_">create</span>(&#123;</span><br><span class="line">	<span class="comment">// 指定使用 v1 版本</span></span><br><span class="line">	<span class="attr">version</span>: <span class="string">&#x27;v01&#x27;</span>,</span><br><span class="line">    <span class="comment">// v1 证书服务</span></span><br><span class="line">    <span class="attr">server</span>: <span class="string">&#x27;https://acme-v01.api.letsencrypt.org/directory&#x27;</span>,</span><br><span class="line">	<span class="comment">// 其他配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 ACME draft 12 证书有个非常好的用处，就是 <strong>支持通配符证书</strong> 了。</p>
<h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>通过 <code>npm</code> 安装 <code>greenlock-express</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install --save greenlock-express@2.x</span></span><br></pre></td></tr></table></figure>

<p>使用起来非常简单，这是 <code>greenlock-express</code> 默认提供的 demo：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greenlock = <span class="built_in">require</span>(<span class="string">&#x27;greenlock-express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;greenlock-express&#x27;</span>).<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="comment">// 证书服务，开发测试使用这个</span></span><br><span class="line">  <span class="comment">// 线上使用 https://acme-v02.api.letsencrypt.org/directory</span></span><br><span class="line">  <span class="attr">server</span>: <span class="string">&#x27;https://acme-staging-v02.api.letsencrypt.org/directory&#x27;</span>,</span><br><span class="line">  <span class="comment">// 联系邮箱</span></span><br><span class="line">  <span class="attr">email</span>: <span class="string">&#x27;john.doe@example.com&#x27;</span>,</span><br><span class="line">  <span class="comment">// 是否同意 Let&#x27;s Encrypt 条款... 这必须为 true 啊，不然走不下去</span></span><br><span class="line">  <span class="attr">agreeTos</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 申请的域名列表，不支持通配符</span></span><br><span class="line">  <span class="attr">approveDomains</span>: [ <span class="string">&#x27;tasaid.com&#x27;</span>, <span class="string">&#x27;www.tasaid.com&#x27;</span> ],</span><br><span class="line">  <span class="comment">// 绑定 express app</span></span><br><span class="line">  <span class="attr">app</span>: <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)().<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">80</span>, <span class="number">443</span>)</span><br></pre></td></tr></table></figure>

<p>证书存在 <code>~/letsencrypt</code>。</p>
<p>当然上面代码只能用于测试&#x2F;开发环境，因为它并没有申请一个有效的证书，而是生成了一个自签名的证书（跟以前的 12306 自签证书一样），用于在开发环境中调试。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><code>greenlock-express</code> 的 <code>create(options)</code> 函数参数签名如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Options</span> &#123;</span><br><span class="line">  <span class="comment">// greenlock-express@2.1.1 新增，draft-11 表示 ACME v2 证书（推荐），v01 表示 v1 证书</span></span><br><span class="line">  <span class="attr">version</span>: <span class="string">&#x27;draft-11&#x27;</span> | <span class="string">&#x27;v01&#x27;</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Express app</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">app</span>: <span class="title class_">Express</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 远程证书服务器</span></span><br><span class="line"><span class="comment">   * 测试环境中可用为 https://acme-staging-v02.api.letsencrypt.org/directory</span></span><br><span class="line"><span class="comment">   * 生产环境中为 https://acme-v02.api.letsencrypt.org/directory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">server</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于接收 let&#x27;s encrypt 协议的邮箱</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否同意协议</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">agreeTos</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在注册域名获取证书前，会执行这个回调函数</span></span><br><span class="line"><span class="comment">   * string[]: 一组需要注册证书的域名</span></span><br><span class="line"><span class="comment">   * 函数: 第一个参数跟 Options 格式差不多，第二个参数是当前自动获取的域名信息，第三个参数是在处理完之后传递的回调函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">approveDomains</span>: <span class="built_in">string</span>[] | <span class="function">(<span class="params">opts, certs: cb</span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新证书最大天数 （以毫秒为单位）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">renewWithin</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新证书的最小天数（以毫秒为单位）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">renewBy</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，在真实的生产环境中， <code>approveDomains</code> 必须为函数，传数组的话不会生效。</p>
<h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><p>生产环境中部署还需要做一些配置改动和引入一些包。</p>
<p>更新包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i --save greenlock-express@2.x</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i --save ursa</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i --save le-challenge-fs</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i --save le-store-certbot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i --save redirect-https</span></span><br></pre></td></tr></table></figure>

<p>生产代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greenlock = <span class="built_in">require</span>(<span class="string">&#x27;greenlock-express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lex = greenlock.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="string">&#x27;draft-11&#x27;</span>,</span><br><span class="line">  <span class="comment">// 注意这里要成这个固定地址</span></span><br><span class="line">  <span class="attr">server</span>: <span class="string">&#x27;https://acme-v02.api.letsencrypt.org/directory&#x27;</span>,</span><br><span class="line">  <span class="attr">challenges</span>: &#123; </span><br><span class="line">    <span class="string">&#x27;http-01&#x27;</span>: <span class="built_in">require</span>(<span class="string">&#x27;le-challenge-fs&#x27;</span>).<span class="title function_">create</span>(&#123; <span class="attr">webrootPath</span>: <span class="string">&#x27;~/letsencrypt/var/acme-challenges&#x27;</span> &#125;) </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">store</span>: <span class="built_in">require</span>(<span class="string">&#x27;le-store-certbot&#x27;</span>).<span class="title function_">create</span>(&#123; </span><br><span class="line">    <span class="attr">webrootPath</span>: <span class="string">&#x27;~/letsencrypt/srv/www/:hostname/.well-known/acme-challenge&#x27;</span> </span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">approveDomains</span>: <span class="function">(<span class="params">opts: <span class="built_in">any</span>, certs: <span class="built_in">any</span>, cb: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    appLog.<span class="title function_">info</span>(<span class="string">&#x27;approveDomains&#x27;</span>, &#123; opts, certs &#125;)</span><br><span class="line">    <span class="keyword">if</span> (certs) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 注意这里如果是这样写的话，一定要对域名做校验</span></span><br><span class="line"><span class="comment">       * 否则其他人可以通过将域名指向你的服务器地址，导致你注册了其他域名的证书</span></span><br><span class="line"><span class="comment">       * 从而造成安全性问题</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// opts.domains = certs.altnames</span></span><br><span class="line">      <span class="comment">// domains 已经支持通配符了（基于 ACME v2）</span></span><br><span class="line">      opts.<span class="property">domains</span> = [ <span class="string">&#x27;tasaid.com&#x27;</span>, <span class="string">&#x27;www.tasaid.com&#x27;</span> ]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      opts.<span class="property">email</span> = <span class="string">&#x27;你的邮箱@live.com&#x27;</span></span><br><span class="line">      opts.<span class="property">agreeTos</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">cb</span>(<span class="literal">null</span>, &#123; <span class="attr">options</span>: opts, <span class="attr">certs</span>: certs &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 redirect-https 用于自动将 HTTP 请求跳到 HTTPS 上</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).<span class="title function_">createServer</span>(</span><br><span class="line">  lex.<span class="title function_">middleware</span>(</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;redirect-https&#x27;</span>)()</span><br><span class="line">   )</span><br><span class="line">  ).<span class="title function_">listen</span>(<span class="number">80</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Listening&#x27;</span>, <span class="string">`for ACME http-01 challenges on: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="variable language_">this</span>.address())&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 绑定 HTTPS 端口</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>).<span class="title function_">createServer</span>(</span><br><span class="line">	lex.<span class="property">httpsOptions</span>, </span><br><span class="line">	lex.<span class="title function_">middleware</span>(app)</span><br><span class="line">  ).<span class="title function_">listen</span>(<span class="number">443</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;App is running at http://localhost:%d in %s mode&#x27;</span>), app.<span class="title function_">get</span>(<span class="string">&#x27;port&#x27;</span>), app.<span class="title function_">get</span>(<span class="string">&#x27;env&#x27;</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Press CTRL-C to stop\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果没有生效，可以检查下 <code>~/letsencrypt</code> 的证书信息，和 443 端口是否打开。</p>
<h2 id="部署-HTTP-2"><a href="#部署-HTTP-2" class="headerlink" title="部署 HTTP&#x2F;2"></a>部署 HTTP&#x2F;2</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP/2">HTTP&#x2F;2</a> 是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP&#x2F;1.1</a> 的升级版，主要来说改进了这些地方：</p>
<ol>
<li>二进制协议：采用二进制流</li>
<li>多路复用：一次请求多次复用管道</li>
<li>服务器推送：解决 HTTP&#x2F;1.x 时代最大的痛点</li>
</ol>
<p>值的注意的是，HTTP&#x2F;2 是支持 HTTP 协议的，只不过浏览器厂商都不愿意支持 HTTP，所以基本上可以认为，用上 HTTP&#x2F;2 的前置条件是必须部署 HTTPS。</p>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><p>早在 2009 年，Google 开发了一个实验性协议，叫做 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SPDY">SPDY</a>，目的解决 HTTP&#x2F;1.x 中的一些设计缺陷。在 SPDY 发布几年后，这个新的实验性协议得到了 Chrome、Firefox 和 Opera 的支持，应用越来越广泛。然后 HTTP 工作组 (HTTP-WG)  在这个 SPDY 的基础上，设计了 HTTP&#x2F;2，所以可以说 SPDY 是 HTTP&#x2F;2 的前身。</p>
<p>关于 HTTP&#x2F;2 的详情可以参考 <a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">这篇文章</a>。</p>
<h3 id="部署-HTTP-2-1"><a href="#部署-HTTP-2-1" class="headerlink" title="部署 HTTP&#x2F;2"></a>部署 HTTP&#x2F;2</h3><p>引入 <code>HTTP/2</code> 在 <code>Node.js</code> 中也十分简单，只需要引入 <code>spdy</code> 包即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i --save spdy</span></span><br></pre></td></tr></table></figure>

<p>然后我们把上一节的代码做一点修改即可支持 HTTP&#x2F;2：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greenlock = <span class="built_in">require</span>(<span class="string">&#x27;greenlock-express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// HTTP/2</span></span><br><span class="line"><span class="keyword">const</span> spdy = <span class="built_in">require</span>(<span class="string">&#x27;spdy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lex = greenlock.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="string">&#x27;draft-11&#x27;</span>,</span><br><span class="line">  <span class="comment">// 注意这里要成这个固定地址</span></span><br><span class="line">  <span class="attr">server</span>: <span class="string">&#x27;https://acme-v02.api.letsencrypt.org/directory&#x27;</span>,</span><br><span class="line">  <span class="attr">challenges</span>: &#123; </span><br><span class="line">    <span class="string">&#x27;http-01&#x27;</span>: <span class="built_in">require</span>(<span class="string">&#x27;le-challenge-fs&#x27;</span>).<span class="title function_">create</span>(&#123; <span class="attr">webrootPath</span>: <span class="string">&#x27;~/letsencrypt/var/acme-challenges&#x27;</span> &#125;) </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">store</span>: <span class="built_in">require</span>(<span class="string">&#x27;le-store-certbot&#x27;</span>).<span class="title function_">create</span>(&#123; </span><br><span class="line">    <span class="attr">webrootPath</span>: <span class="string">&#x27;~/letsencrypt/srv/www/:hostname/.well-known/acme-challenge&#x27;</span> </span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">approveDomains</span>: <span class="function">(<span class="params">opts: <span class="built_in">any</span>, certs: <span class="built_in">any</span>, cb: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    appLog.<span class="title function_">info</span>(<span class="string">&#x27;approveDomains&#x27;</span>, &#123; opts, certs &#125;)</span><br><span class="line">    <span class="keyword">if</span> (certs) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 注意这里如果是这样写的话，一定要对域名做校验</span></span><br><span class="line"><span class="comment">       * 否则其他人可以通过将域名指向你的服务器地址，导致你注册了其他域名的证书</span></span><br><span class="line"><span class="comment">       * 从而造成安全性问题</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// opts.domains = certs.altnames</span></span><br><span class="line">      <span class="comment">// domains 已经支持通配符了（基于 ACME v2）</span></span><br><span class="line">      opts.<span class="property">domains</span> = [ <span class="string">&#x27;tasaid.com&#x27;</span>, <span class="string">&#x27;www.tasaid.com&#x27;</span> ]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      opts.<span class="property">email</span> = <span class="string">&#x27;你的邮箱@live.com&#x27;</span></span><br><span class="line">      opts.<span class="property">agreeTos</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">cb</span>(<span class="literal">null</span>, &#123; <span class="attr">options</span>: opts, <span class="attr">certs</span>: certs &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 redirect-https 用于自动将 HTTP 请求跳到 HTTPS 上</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).<span class="title function_">createServer</span>(</span><br><span class="line">  lex.<span class="title function_">middleware</span>(</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;redirect-https&#x27;</span>)()</span><br><span class="line">   )</span><br><span class="line">  ).<span class="title function_">listen</span>(<span class="number">80</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Listening&#x27;</span>, <span class="string">`for ACME http-01 challenges on: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="variable language_">this</span>.address())&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP/2</span></span><br><span class="line">spdy.<span class="title function_">createServer</span>(lex.<span class="property">httpsOptions</span>, lex.<span class="title function_">middleware</span>(app)).<span class="title function_">listen</span>(<span class="number">443</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Listening https&#x27;</span>, <span class="string">`for ACME tls-sni-01 challenges and serve app on: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="variable language_">this</span>.address())&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>至于 HTTP&#x2F;2 相关的技术应用，会在后续篇幅中再为大家讲解。</p>
<blockquote>
<p>2018-08-23，今天无意中发现 log4js 没有写请求入口的 access 日志，经排查发现是因为开启了 HTTP&#x2F;2 导致的</p>
</blockquote>
<p>通过 <code>spdy</code> 启动了 HTTP&#x2F;2 的服务之后，log4js 使用 <code>connectLogger</code> 注入 <code>express</code> 中间件的时候，在入口处不会写 access 日志：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志不会写</span></span><br><span class="line">app.<span class="title function_">use</span>(log.<span class="property">Log4js</span>.<span class="title function_">connectLogger</span>(log.<span class="property">accessLogger</span>, &#123; <span class="attr">level</span>: log.<span class="property">accessLogger</span>.<span class="property">level</span> &#125;))</span><br></pre></td></tr></table></figure>

<p>具体的现象比较怪异：在浏览器中访问的时候没有 access 日志，但是搜索引擎抓取的时候却有 access 日志，于是怀疑是不是 HTTP&#x2F;2 导致的问题。</p>
<p>查到 <a target="_blank" rel="noopener" href="https://github.com/log4js-node/log4js-node/blob/v3.0.5/lib/connect-logger.js#L244-L260">log4js&#x2F;lib&#x2F;connect-logger.js</a> 源码之后，发现 <code>log4js</code> 在注入 <code>express</code> 中间件的时候，监听了 <code>express</code> 的 <code>finish</code> 事件，搜索引擎抓取的时候会主动关闭 HTTP&#x2F;2 的长连接，所以自然就执行了 <code>finish</code> 事件。</p>
<p>而开启了 HTTP&#x2F;2 之后在浏览器中打开页面是不会触发 <code>finish</code> 事件的，从而导致 <code>log4js</code> 没有写 access 日志。</p>
<p>最终我选择的解决方案是下掉 HTTP&#x2F;2。因为 HTTP&#x2F;2 的 server push 和多路复用，在现代 web 中大部分只适用于 CDN 场景，said 项目本身用不到这些特性。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/4f3c3fec/" data-id="cloizszuw0006xww62crh4935" data-title="Node.js 部署免费/自动续订 HTTPS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/Said2-0的一些开发经验" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/67e55b26/" class="article-date">
  <time class="dt-published" datetime="2018-03-07T18:10:00.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/67e55b26/">Said 2.0 的一些开发经验</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Said 在三个月内使用了新的技术进行了重写，这三个月收获丰厚，和大家分享一下此次架构的一些心路历程。</p>
<blockquote>
<p>JavaScript - 前端开发交流群：377786580</p>
</blockquote>
<h2 id="Said-1-x-的痛点"><a href="#Said-1-x-的痛点" class="headerlink" title="Said 1.x 的痛点"></a>Said 1.x 的痛点</h2><p><code>Said</code> 于两年前（2016-02-04）上线，而因为自己磨蹭，第一版开发了很久，开发的同时正是前端技术各种爆发的时候，经过了几次技术选型，最终选定了服务层使用 <code>C#</code>，数据存储使用和 <code>C#</code> 的技术生态融合一体的 <code>Sql Server</code>（毕竟都是微软亲儿子）。因为自己以前做过 <code>C#</code>，同时希望自己在做前端的时候，后端的技术也不要被遗弃。</p>
<p>在前端部分的选型，考虑到前台站点主要突出轻与快，于是直接上 <code>jQuery</code>。</p>
<p>而后台的前端部分，考虑到交互频繁和表单复杂，当时选择了 <code>bootstrap</code> 和司徒正美的 <code>avalon</code>，为什么当初没有选择 <code>vue</code>？ 因为在后台快开发完的时候 <code>vue</code> 才发第一版。</p>
<p>在开发中逐渐遇到了很多问题。</p>
<p>首先是后台是通过 <code>.net mvc</code> 的 <code>razor</code> 视图引擎渲染出了页面，然后把数据注入到页面中，<code>js</code> 去读取数据，还原数据并渲染。前后端不纯粹没有分离，其实后台这种项目非常适合做单页使用前后端分离，因为前后端揉合在一起十分痛苦。后台也没有引入类似 <code>npm</code> 的包管理，导致引用的第三库都是自己下载然后 copy 到项目中。好处就是可以自定义开发，例如引入了 <code>showdown.js</code> 来解析 <code>markdown</code>，针对 <code>showdown.js</code> 自己做了很多定制化开发。缺点十分明显，一切靠手动，升级更痛苦。</p>
<p>同样，也没有完善的模块切割和打包机制，导致后来进行功能改造的时候十分痛苦，改一处牵连多处。</p>
<p>前台部分（也就是 <code>https://tasaid.com</code>），使用传统的 <code>jquery</code>。同样没有引入版本控制，兼容性自己把控。<code>css</code> 方面使用了 <code>sass</code>，但是是通过 <a target="_blank" rel="noopener" href="http://koala-app.com/index-zh.html">koala</a> 工具进行的编译，没有和项目融合在一起。</p>
<p>这其中，<code>js</code> 的打包压缩是个痛点，不过后来发现了 <code>.net mvc</code> 的 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xwgli/p/3296809.html">Bundle</a> 能够在项目运行时自动压缩打包文件，这个问题才解决了。</p>
<p>以上痛点基本上忍一忍就可以，但是后端服务层的问题不能忍，后端服务层出现的问题才让我决定了此次的升级。</p>
<p>服务层（也可以叫后端服务）是使用 <code>C#</code> 进行编写的，引入了大名鼎鼎的　<code>entity framework</code> 框架，让我全程不用关心数据库只需要定义 Model 写业务即可，但由于是第一次使用 <code>entity framework</code> ，在后续出现了很多的问题，最大一次问题是 <a target="_blank" rel="noopener" href="https://github.com/linkFly6/said/issues/12">某些情况下连两个并发可能都扛不住</a>。遇到这些问题的时候，由于精力有限不是主攻这个方向的，解决起来难度系数比较大。而且由于国内 <code>C#</code> 使用率的问题，在人脉圈找人帮忙解决问题都很难。</p>
<p>之后 <code>Said</code> 又部署了 HTTPS，部署完了之后产出了这篇影响还不错的文章： 《<a target="_blank" rel="noopener" href="https://tasaid.com/blog/20161005024923.html">从 HTTP 到 HTTPS - IIS 部署免费 HTTPS</a>》，本以为就此安心了，结果分分钟被打脸。在某些地方 HTTPS 访问 <a target="_blank" rel="noopener" href="https://tasaid.com/">https://tasaid.com</a> 的时候，会出现 <code>403 - 禁止访问: 访问被拒绝</code>。</p>
<p>这种问题十分头疼，因为有些用户 HTTPS 访问是没有问题的， 而另外一些用户 HTTPS 却访问不了，例如我家里的电脑访问没有问题，公司的电脑访问就 <code>403</code> 了，而在公司用手机访问又没有问题。这一问题排查了近一个月，社区大佬也问了一圈没有人知道为什么，各种配置都查了根本没有头绪，导致了此次升级的诱因之一。</p>
<p>另外一个问题是某些情况下会出现移动端访问变成 PC 端页面，<code>Said</code> 是使用 <code>.net mvc</code> 提供的 <code>MVC Display Mode</code> 来针对不同的设备显示不同页面，然后这一问题查了许久也成了玄学问题。</p>
<p>后面还有各项问题，例如服务器前期比较稳定，在后来平均每 15 天内存就会被耗尽，只能重启服务器来解决，问题也懒得排查了。在去年双十一观望了下服务器的活动，发现活动还挺不错，横向比较了下 <code>Windows Server</code> 和 <code>Linux Server</code>， <code>Windows Server</code> 吃资源还是太厉害了，于是直接订了一年的服务器，然后开始着手准备 <code>Said</code> 的重构。</p>
<p>大体来说，痛点集中在这些：</p>
<ul>
<li>前后端没有分离，导致混合编写维护十分不便</li>
<li>没有良好的包管理系统，导致第三方库升级艰难</li>
<li>模块系统没有控制好，同样导致维护成本很高</li>
<li>社区不够庞大，导致问题很难被解决</li>
</ul>
<h2 id="凤凰涅槃"><a href="#凤凰涅槃" class="headerlink" title="凤凰涅槃"></a>凤凰涅槃</h2><p><code>Said</code> 在重构之初本来考虑着要不要使用 <code>.net core</code> (.net 跨平台) 技术来重构，后来思索再三，考虑到项目语言风格的一体性（编码体验一致），前端的蓬勃发展（遇到的问题都可以在社区找到解决方案），以及对自己前端发展技术的一次总结和试验，决定了技术架构如下：</p>
<ul>
<li>语言使用 <a target="_blank" rel="noopener" href="https://tslang.cn/">TypeScript</a>。2017 年中旬我已经实验过 <code>TypeScript</code>，爱不释手感觉自己快要不会写 js 了。</li>
<li>服务层使用 <a target="_blank" rel="noopener" href="http://nodejs.cn/">nodejs</a>。本质上 <code>TypeScript</code> 编译到 <code>nodejs</code>。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://www.mongodb.com/">mongodb</a> 存储数据。<code>Said</code> 的数据关系并不复杂，使用 <code>mongodb</code> 更方便迅捷。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">npm</a> 作为包管理工具。<code>npm</code> 已经确定是整个 <code>nodejs/js</code> 生态圈王牌地位了。</li>
<li>后台使用 <a target="_blank" rel="noopener" href="https://doc.react-china.org/">reactjs</a> + <a target="_blank" rel="noopener" href="https://tslang.cn/docs/handbook/jsx.html">tsx</a> 作为基本框架和语言。<code>tsx</code> 是 <code>TypeScript</code> 专门针对 <code>jsx</code> 所定制的语言，强化了 <code>jsx</code> 的静态类型，比起 <code>vue</code> 来说和 <code>TypeScript</code> 结合的体验简直不要太爽。</li>
<li>后台使用 <a target="_blank" rel="noopener" href="https://ant.design/docs/react/introduce-cn">antd</a> 作为 <code>UI</code> 框架。<code>antd</code> 也是使用 <code>tsx</code> 来编写的。</li>
<li><code>icon font</code> 全部使用 <a target="_blank" rel="noopener" href="http://www.iconfont.cn/">阿里巴巴矢量图标库</a>。 利用阿里巴巴矢量图标库收集和在线生成字体文件。</li>
<li>使用 <a target="_blank" rel="noopener" href="http://stylus-lang.com/">stylus</a> 作为 <code>css</code> 预处理器。</li>
<li>使用七牛存储静态文件。</li>
</ul>
<h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>语言层面，选用 <code>TypeScript</code> 是因为它的静态类型让 js 有了质的飞跃。这一点可以参考我的 《<a target="_blank" rel="noopener" href="https://tasaid.com/blog/20171011231943.html">从 JavaScript 到 TypeScript 系列</a>》，强烈推荐 <code>TypeScript</code>。</p>
<p>数据存储方面，因为 <code>mongodb</code> 上手简单方便，结构化数据存储非常适合 <code>Said</code> 的应用场景，并且和 <code>nodejs</code> 结合浑然天成。存储数据只需要声明一组 JSON 然后保存，非常简便。</p>
<p>而<code>npm</code> 的包管理直接解决了过去引入第三方库，升级不方便的痛点，现在可以跟着社区的主流针对包进行升级，维护成本非常低。</p>
<p>最后，选用七牛云存储是因为 <code>Said</code> 过去都是自己存储和处理静态资源，浪费服务器资源和流量。而七牛云存储的价格不算贵，配置起来也十分方便，所以直接将静态文件扔上去然后走七牛的 CDN 服务加快速度。现在的 <code>Said</code> 不会存储任何静态资源，所有的资源都上传到了 CDN，管理十分方便。很低的价格和良好的服务就能够享受到 CDN 服务。</p>
<h3 id="后台技术"><a href="#后台技术" class="headerlink" title="后台技术"></a>后台技术</h3><p>后台本质上是一个单页应用，使用了 <code>webpack</code> 打包成单页。部署前会把 <code>js/css</code> 通过脚本全部上传到七牛云上，然后在服务层只需要输出打包后的 <code>html</code> 即可。</p>
<p>技术层面，后台主要使用了 <code>react</code>，同时结合了 <a target="_blank" rel="noopener" href="http://cn.mobx.js.org/">mbox</a> 做状态管理。服务层(<code>nodejs</code>) 提供接口， <code>mbox</code> 读取接口数据然后自动渲染。为了配合 <code>react</code> 中可以更优雅操作 <code>state</code>， 引入了 <a target="_blank" rel="noopener" href="https://facebook.github.io/immutable-js/">immutable.js</a>。</p>
<p>UI 则使用了组件丰富的 <code>antd</code>，丰富的组件让开发很迅捷，同时良好的各种细节动画让自己也省心很多。</p>
<p>后台使用了 <a target="_blank" rel="noopener" href="https://github.com/JedWatson/react-codemirror">react-codemirror</a> 作为 <code>markdown</code> 编辑器，同时服务层使用 <a target="_blank" rel="noopener" href="https://github.com/markedjs/marked">marked</a> 解析 <code>markdown</code>。代码高亮使用传统老牌 <a target="_blank" rel="noopener" href="https://github.com/isagalaev/highlight.js/">highlight.js</a>。</p>
<h3 id="前台和服务层"><a href="#前台和服务层" class="headerlink" title="前台和服务层"></a>前台和服务层</h3><p>前台的客户端脚本也使用了 <code>webpack</code> 打包， 先把 <code>TypeScript</code> 编译到 <code>js</code>，然后使用 <a target="_blank" rel="noopener" href="https://babeljs.cn/">babel</a> 编译代码到 <code>es5</code>，用于解决代码兼容性问题。之所以还加 <code>babel</code> 是因为 <code>TypeScript</code> 只编译语法特性，而不会附加 <code>polyfill</code>。同 <code>Said 1.x</code> 一样，前台也只引用了 <code>jQuery</code>，迎合 <code>Said</code> 一开始要追求的访问性能 —— 轻而快。前台所有的资源和后台一样，在部署前上传到七牛云，然后修正链接即可。</p>
<p>服务端直接用 <code>TypeScript</code> 编译产出 <code>es6</code>，因为服务端跑的 <code>node 8</code>，不需要考虑太多兼容性问题。</p>
<p>过去 <code>Said</code> 会在用户访问的时候往数据库插入记录用于统计，后来这张表存了 4W+ 数据，现在使用 <a target="_blank" rel="noopener" href="https://github.com/log4js-node/log4js-node">log4js</a> 直接写本地日志，后续再单独针对日志做分析即可。</p>
<p>统计使用 <a target="_blank" rel="noopener" href="https://web.umeng.com/main.php?spm=a211g2.181323.0.0.3cb23604SgRryz&c=user&a=index">cnzz - 友盟统计</a>，国内目前没有找到比 <code>cnzz</code> 更全的统计（也有其他的第三方统计平台心怀鬼胎），同时会根据自己写的 log 做数据分析（基本上只是看一眼….）。</p>
<p>通过 <a target="_blank" rel="noopener" href="https://github.com/Daplie/greenlock-express">greenlock-express</a> 来部署 <code>HTTPS</code>， <code>greenlock-express</code> 会自动申请&#x2F;续订 <a target="_blank" rel="noopener" href="https://letsencrypt.org/">letsencrypt</a> 的免费证书，从而让站点一直运行 HTTPS（尚未验证，等三个月 <code>letsencrypt</code> 证书到期了之后就可以知道是不是自动续订了）。然后使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/spdy">spdy</a> 部署了 HTTP&#x2F;2。关于这里可以参考 《<a target="_blank" rel="noopener" href="https://tasaid.com/blog/2018031415094468.html">Node.js 部署免费&#x2F;自动续订 HTTPS</a>》。</p>
<p>服务器上使用了 <a target="_blank" rel="noopener" href="https://github.com/Unitech/pm2">pm2</a> 作为 <code>nodejs</code> 的进程托管。<code>pm2</code> 用于管理和守护 <code>nodejs</code> 的进程，在 <code>nodejs</code> 崩溃的时候可以自动重启服务。<code>Said</code> 在部署的时候，根据服务器 CPU 的个数部署了集群模式 (<code>cluster</code>)，因为 <code>nodejs</code> 是单线程的，同一个 CPU 下同一时间只会跑一个 <code>nodejs</code> 服务，<code>cluster</code> 模式可以充分利用多核资源。</p>
<p>在部署中遇到了 <code>log4js</code> 不写 log，使用 <code>node</code> 直接运行项目是没问题的，一旦使用 <code>pm2</code> 部署就不写 <code>log</code>，查资料看到了 <a target="_blank" rel="noopener" href="http://blog.yourtion.com/fix-log4js-with-pm2-not-work.html">这个</a>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log4js.<span class="title function_">configure</span>(&#123;</span><br><span class="line">  <span class="attr">appenders</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">categories</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">pm2</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>这是 <code>Said</code> 此次升级后的性能评测报告：</p>
<p>资源加载时间报告：</p>
<p><img src="//static.tasaid.com/blogs/bae67beb70e48011c7e352b842a4dc71.png" alt="said 加载时间"></p>
<p>&nbsp;</p>
<p>评分报告：</p>
<p><img src="//static.tasaid.com/blogs/1f8c6a7af0c3d638e1b118ce5ca031ee.png" alt="said 评分 "></p>
<blockquote>
<p>评分站点: <a target="_blank" rel="noopener" href="http://www.mmtrix.com/index">http://www.mmtrix.com/index</a></p>
</blockquote>
<blockquote>
<p>2018年11月11日 02:42:45：服务器已经从青岛机房迁移到张家口机房（只是因为便宜…）。</p>
</blockquote>
<blockquote>
<p>JavaScript - 前端开发交流群：377786580</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/67e55b26/" data-id="cloizszuy000gxww6fm847lw2" data-title="Said 2.0 的一些开发经验" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Said/" rel="tag">Said</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/JavaScript中的taskqueues" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/d4134bcf/" class="article-date">
  <time class="dt-published" datetime="2018-01-18T05:27:00.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/d4134bcf/">JavaScript 中的 task queues</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JavaScript 是单线程的，所有的任务都放在 “任务队列”  中<br>从而衍生了 event loops 机制<br>我们这次要讨论的，则是 event loop 的背后 —— task queues 和异步任务 API 的执行细节</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<h2 id="从-event-loop-说起"><a href="#从-event-loop-说起" class="headerlink" title="从 event loop 说起"></a>从 event loop 说起</h2><p>众所周知，JavaScript 是单线程的，所有的任务都视为事件，放在 “任务队列”  中，循环读取并执行这个事件队列，这就是 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">Event loops</a> (事件循环) 机制。</p>
<p>在浏览器中，有两种 event loop，分别是 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/browsers.html#browsing-context">brwosing-context</a>(浏览器上下文) 和 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/workers.html#workers">Web workers</a>。前者是浏览器中 JavaScript 的 event loop，后者应用在 JavaScript 的 <code>web worker</code> 多线程。</p>
<p><img src="//static.tasaid.com/blogs/4c4d2d95f06528c46f5f3f360b4f7ed2.png" alt="event loop"></p>
<p>在 JavaScript 函数的执行中，会生成 stack(栈) 和 heap (堆)，同时还有一个 task queues(任务队列)，函数中所调用的外部函数都放在 task queues 中，当函数主线程执行完毕，就会从 task queues 中依次取出对应的任务并执行。</p>
<p>在一个 event loop 中，会有一个或多个<strong>task queues</strong>(任务队列)。</p>
<p>我们这篇文章要讲的，就是讲 <code>task queues</code> 和它里面的东西，受 <code>task queues</code> 最大影响的，就是异步 API 的调用时机 (例如 <code>setTimeout/process.nextTick/promise.then</code>)。</p>
<h2 id="task-queues-任务队列"><a href="#task-queues-任务队列" class="headerlink" title="task queues 任务队列"></a>task queues 任务队列</h2><p>在每个 event loop 下会有一个或多个 <code>task queues</code>(任务队列)，而每个任务都会有一个对应的任务源 <code>target source</code>(任务源)，每个任务都放到对应任务源的任务队列中。</p>
<p>每个任务源根据不同浏览器或其他引擎 (例如 nodejs) 的实现，自己安排不同的优先级，从而调控某类任务的执行顺序。</p>
<blockquote>
<p>例如浏览器认为鼠标事件频率很高，所以可以把鼠标事件的任务源优先级设的更高，而 nodejs 中 <code>i/o</code> 优先级更高，就针对此类任务源可以提升执行优先级。</p>
</blockquote>
<p><code>macrotask</code>(宏任务)  和 <code>microtask</code>(微任务) 就是这些针对这些任务不同的执行时机分类而出。</p>
<h2 id="macrotask-和-microtask"><a href="#macrotask-和-microtask" class="headerlink" title="macrotask 和 microtask"></a>macrotask 和 microtask</h2><p>纵观 WHATWG 和 ECMAScript 规范，都没有明确指出 <code>macrotask</code>(宏任务) 和 <code>microtask</code>(微任务)，检索 V8&#x2F;nodejs 源码没有找到 <code>macrotask</code>(只找到 <code>microtask</code>)。 </p>
<p><code>macrotask</code> 和 <code>microtask</code> 是对任务的行为作出的分类，许多相关文章都提及了 <code>macrotask</code>(宏任务) 是一个大任务，而 <code>microtask</code>(微任务) 则是每个 event loop 中快速处理的小任务。</p>
<p><code>microtask queues</code> 是一种快速任务队列，设计的初衷是在某个 <code>task</code> 执行后快速执行的一个队列。</p>
<p><code>macrotask</code> 和 <code>microtask</code> 它们只是一个抽象概念，具体随便引擎怎么实现。</p>
<blockquote>
<p>笔者个人觉得这 macrotask 这个概念还是有争议的</p>
</blockquote>
<h2 id="WHATWG-中的-task-queues"><a href="#WHATWG-中的-task-queues" class="headerlink" title="WHATWG 中的 task queues"></a>WHATWG 中的 task queues</h2><p>在浏览器环境下， <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue">WHATWG</a> 规范中描述了event loop 的 <code>task queues</code>(任务队列)。</p>
<p>而每个 event loop 中，还有一个 <code>microtask queues</code>(微任务队列)，该队列将任务按照不同的任务源 (类型) 进行分类，每个任务的任务源都被叫做 <code>microtask task source</code>(微任务源)。</p>
<ul>
<li>在 event loop 中，会有一个或多个 <code>task queues</code>(任务队列)</li>
<li>每个 event loop 中，都有一个 <code>microtask queues</code>(微任务队列)</li>
</ul>
<p>然后我们看下 <code>WHATWG</code> 规范中的 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">event loop 执行模型</a>：</p>
<ol>
<li><p>从 <code>task queues</code> 取出一个 <code>task</code> ，如果没有 <code>task</code> 则直接跳转到 6 (执行 <code>microtasks</code> 队列)</p>
</li>
<li><p>将取出来的 <code>task</code> 标记正在运行</p>
</li>
<li><p>运行这个 <code>task</code></p>
</li>
<li><p>去掉这个 <code>task</code> 正在运行的标记</p>
</li>
<li><p>在 <code>task queues</code> 移除这个  <code>task</code></p>
</li>
<li><p>运行 <code>microtask</code> 队列</p>
<ul>
<li>a. 标记正在运行 <code>microtask</code> 队列</li>
<li>b. 如果 <code>microtask</code> 队列不为空，则取出来循环执行</li>
<li>c. 标记 <code>microtask</code> 队列运行完毕</li>
<li>d. 销毁这个 <code>microtask</code> 队列</li>
</ul>
</li>
<li><p>引擎自行任务处理 (例如浏览器会进行 DOM 渲染更新)</p>
</li>
<li><p>销毁这个 <code>task</code></p>
</li>
<li><p>循环执行第 1 步</p>
</li>
</ol>
<p><img src="//static.tasaid.com/blogs/03ab1ebf0428b28d63dcad49ae2de8c5.png" alt="task queues"></p>
<p>上面的步骤简化来说就是：</p>
<ol>
<li>从 <code>task queues</code> 任务队列中取出 <code>task</code> 并执行</li>
<li>然后执行 <code>microtasks</code> 队列</li>
</ol>
<h2 id="ECMAScript-中的-jobs-和-job-queues"><a href="#ECMAScript-中的-jobs-和-job-queues" class="headerlink" title="ECMAScript 中的 jobs 和 job queues"></a>ECMAScript 中的 jobs 和 job queues</h2><p>前面我们看到的 <code>task queues</code> 是 <code>WHATWG</code> 规范下的任务队列，而在 <a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues">ECMAScript 规范</a> 下，则提出了 <code>jobs</code>  和 <code>job quques</code> 的概念：</p>
<p><code>job</code> 是一个抽象操作，当前没有正在执行的任务的时候，会从 <code>job queues</code> 队列中取出一个 <code>job</code> 执行。</p>
<p><code>job queues</code> 同样根据不同的任务源进行分类，规范规定每个 ECMAScript 实现必须至少实现两个 <code>job queues</code>：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ScriptJobs</td>
<td align="left">运行一般 ECMAScript 脚本和 module 的任务队列</td>
</tr>
<tr>
<td align="left">PromiseJobs</td>
<td align="left">处理 <code>Promise</code> 任务的异步队列</td>
</tr>
</tbody></table>
<p>在这里，不同的引擎也可以针对 <code>job queues</code> 进行分类，然后重排优先级。</p>
<p>可以看到，这个 <code>job queues</code> 和前面 WHATWG 规范的 <code>task queues</code> 有异曲同工之妙。</p>
<h2 id="nodejs-中的-tick"><a href="#nodejs-中的-tick" class="headerlink" title="nodejs 中的 tick"></a>nodejs 中的 tick</h2><p>在 nodejs 中，每个 event loop 称之为 <code>tick</code>。官方贴出这样一个 event loop 任务执行顺序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>timers：检查 <code>setTimeout/setInterval</code></li>
<li>I&#x2F;O callbacks：大部分回调函数都在这里执行，除了 <code>close/timers/setImmediate</code> 的回调</li>
<li>idle, prepare：引擎内部使用</li>
<li>poll：检索新的 I&#x2F;O 事件，等待到达阈值的轮询任务队列，例如 <code>setTimeout/setInterval</code> 在 <strong>timer</strong> 阶段检查到即将到达阈值，则会在 <strong>poll</strong> 阶段等待阈值并执行</li>
<li>check：调用 <code>setImmediate</code></li>
<li>close callbacks：关闭类回调，例如 <code>socket.on(&#39;close&#39;, ...)</code> 的回调</li>
</ul>
<p>在每个阶段运行中，如果存在新的队列任务，则会由内核进行重新排队。</p>
<p><img src="//static.tasaid.com/blogs/dc2678d0975fdd7aae68ae161ac0751b.png" alt="nodejs tick"></p>
<h3 id="setImmediate-VS-setTimeout"><a href="#setImmediate-VS-setTimeout" class="headerlink" title="setImmediate() VS setTimeout()"></a>setImmediate() VS setTimeout()</h3><p><code>setImmediate</code> 是一个特殊的计时器，它和普通计时器 (<code>setTimeout/setInterval</code>) 不同的是它在独特的任务周期内执行：</p>
<ul>
<li><code>setImmediate()</code> 在  <strong>check</strong> 阶段完成后执行</li>
<li><code>setTimeout()</code> 在到达指定毫秒后(尽可能)执行</li>
</ul>
<p>在普通的主流程 (main module) 中它们的行为不可预测 (取决于进程性能)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout_vs_immediate.js</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line"><span class="built_in">timeout</span></span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line"><span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>

<p>但如果在 I&#x2F;O 的生命周期内调用这两个函数，就可以看到区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout_vs_immediate.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line"><span class="built_in">timeout</span></span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line"><span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>

<p>因为在 I&#x2F;O 生命周期中，下一个阶段是 <strong>check</strong>，<strong>check</strong> 完成后会调用 <code>setImmediate()</code>。</p>
<p>值的一提的是 <code>setTimeout()</code> 有最低 4ms 执行延迟，这是各大引擎约定成俗的。</p>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p>在异步 API 中，<code>process.nextTick()</code> 是个异类，即使它是异步 API 的一部分，但是也没有出现在上面的图中。因为 process.nextTick() 在技术上不属于 event loop，而是挂载在 <a target="_blank" rel="noopener" href="https://github.com/nodejs/node/blob/v9.4.0/lib/internal/process/next_tick.js#L13">nextTickQueue</a> 中。</p>
<p>从 node event loop 的流程图中可以看到，nextTickQueue 贯穿了整个 event loop，nextTickQueue 会在每个阶段之后执行 (microtask)。</p>
<p>在每次 event loop 任意阶段结束后，都会保证 nextTickQueue 一定被清空了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setImmediate_vs_process.nextTick.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node setImmediate_vs_process.nextTick.js</span><br><span class="line">nextTick</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>process.nextTick  和 setImmediate 名字其实是应该是对调的，因为 nodejs 早期对 api 命名错误导致了这个问题，随着 nodejs 使用者很多，为了避免大规模出现问题，这两个 API 的名字不会被修正（互相调换）。</p>
</blockquote>
<h2 id="异步-API-的执行顺序"><a href="#异步-API-的执行顺序" class="headerlink" title="异步 API 的执行顺序"></a>异步 API 的执行顺序</h2><p>前面说了那么多，还提到什么 <code>macrotask/microtask</code>，那么我们怎么来验证呢？很简单，把所有异步代码在同一个任务中跑一遍，再结合上面所提到的执行顺序，就可以得到答案。</p>
<p>可以以 setTimeout() 作为分割点，setTimeout() 之前的都是 <code>microtask</code>，而 setTimeout() 和之后的则都是 <code>task</code>(大家也可以认为叫做 <code>macrotask</code>)。</p>
<p>值的注意的是，考虑到 <code>setImmediate</code> 在主流程 (main module) 的执行时机不可预测，我们将测试代码都放到 I&#x2F;O 中，从而保证所有异步代码都在同一个 event loop 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证所有 API 测试都在同一个 task 内</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setTimeout1</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myInterval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setInterval&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setTimeout2</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">    <span class="comment">// promise3</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setTimeout3</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout3&#x27;</span>)</span><br><span class="line">      <span class="built_in">clearInterval</span>(myInterval)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// promise1</span></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">start</span><br><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setImmediate</span><br><span class="line">setTimeout1</span><br><span class="line">setInterval</span><br><span class="line">setTimeout2</span><br><span class="line">promise3</span><br><span class="line">setInterval</span><br></pre></td></tr></table></figure>

<p>大概说下流程 （在 I&#x2F;O 中）：</p>
<ol>
<li><p>第一圈 event loop，首先整体 script 是一个 <code>task</code>，所以率先打印了 <code>start</code> 和 <code>end</code></p>
</li>
<li><p>发现 <code>setTimeout/setImmediate</code>，将它们的回调函数推到 event loop 下一个任务队列中 (task)</p>
</li>
<li><p><code>process.nextTick/Promise.resolve</code> 在上一阶段结束后被执行并输出，它们都是 <code>microtask</code></p>
</li>
<li><p>进入第一圈 event loop 的 <strong>check</strong> 阶段，所以输出 <code>setImmediate</code></p>
</li>
<li><p><strong>进入第二圈 event loop</strong> 的 <strong>timer</strong> 阶段，依次输出 <code>setTimeout1</code>、<code>setInterval</code>、<code>setTimeout2</code>。同时在 <code>setTimeout2</code> 中：</p>
<ul>
<li>将 <code>promise3</code> 推到本次 event loop 的 <code>microtask</code> 中</li>
<li>将 <code>setInterval</code> 再次推到下一个 event loop 的任务队列中</li>
<li>将 <code>setTimeout3</code> 推到下一个 event loop 的任务队列中</li>
</ul>
</li>
<li><p>执行本次 event loop 的 <code>microtask</code>，输出 <code>promise3</code></p>
</li>
<li><p><strong>进入第三圈 event loop</strong>，依次输出 <code>setInterval</code> 和 <code>setTimeout3</code></p>
<ul>
<li>同时，在 <code>setTimeout3</code> 中清除了 <code>setInterval</code></li>
</ul>
</li>
<li><p>至此，结束任务</p>
</li>
</ol>
<p>图片流程如下 (黑箭头表示任务流程，蓝虚线表示进入下一个 event loop，绿虚线表示当前 event loop 的下一阶段)：</p>
<p><img src="//static.tasaid.com/blogs/71b7b3de5a9f0524534484b8d161500d.png" alt="demo event loop"></p>
<p>最后我们再总结下：</p>
<p><code>task</code> 或 <code>macrotasks</code> API ：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>requestAnimationFrame</li>
<li>I&#x2F;O</li>
<li>UI 渲染</li>
</ul>
<p><code>microtasks</code> API：</p>
<ul>
<li>process.nextTick</li>
<li>Promises</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<p>各个异步 API 优先级：</p>
<p><code>process.nextTick</code> &gt; <code>promise.then</code> &gt; <code>setImmediate</code> &gt;  <code>setTimeout</code> &#x3D; <code>setInterval</code> </p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><ul>
<li><a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">WHATWG - event loops</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues">ECMAScript® 2015 Language Specification</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ccforward/cc/issues/48">理解事件循环二(macrotask和microtask)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/">The JavaScript Event Loop: Explained</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">The Node.js Event Loop, Timers, and process.nextTick()</a></li>
<li><a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36972010/answer/71338002">Promise的队列与setTimeout的队列有何关联？</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">MDN - 并发模型与事件循环 </a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context">StackOverflow - Difference between microtask and macrotask within an event loop context</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/d4134bcf/" data-id="cloizszuv0004xww690vqgufz" data-title="JavaScript 中的 task queues" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/JavaScript和TypeScript交叉口——类型定义文件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/d4d0a06d/" class="article-date">
  <time class="dt-published" datetime="2017-11-02T14:51:00.000Z" itemprop="datePublished">2017-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/d4d0a06d/">JavaScript 和 TypeScript 交叉口 —— 类型定义文件(*.d.ts)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 <a target="_blank" rel="noopener" href="http://tasaid.com/blog/20171011231943.html">《从 JavaScript 到 TypeScript 系列》</a> 文章我们已经学习了 TypeScript 相关的知识。<br>TypeScript 的核心在于静态类型，我们在编写 TS 的时候会定义很多的类型，但是主流的库都是 JavaScript 编写的，并不支持类型系统。那么如何让这些第三方库也可以进行类型推导呢？</p>
<p>这篇文章我们来讲解 JavaScript 和 TypeScript 的静态类型交叉口 —— 类型定义文件。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<h2 id="类型定义文件"><a href="#类型定义文件" class="headerlink" title="类型定义文件"></a>类型定义文件</h2><p>在 TypeScript 中，我们可以很简单的，在代码编写中定义类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IBaseModel</span> &#123;</span><br><span class="line">  <span class="title function_">say</span>(<span class="attr">keys</span>: <span class="built_in">string</span>[] | <span class="literal">null</span>): <span class="built_in">object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">IBaseModel</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是主流的库都是 JavaScript 编写的，TypeScript 身为 JavaScript 的超集，自然需要考虑到如何让 JS 库也能定义静态类型。</p>
<p>TypeScript 经过了一系列的摸索，先后提出了 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/tsd">tsd</a>(已废弃)、<a target="_blank" rel="noopener" href="https://github.com/typings/typings">typings</a>(已废弃)，最终在 TypeScript 2.0 的时候重新整理了类型定义，提出了 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 就是让你把 “类型定义文件(*.d.ts)”，发布到 <code>npm</code> 中，配合编辑器(或插件)，就能够检测到 JS 库中的静态类型。</p>
<p>类型定义文件的以 <code>.d.ts</code> 结尾，里面主要用来定义类型。</p>
<p>例如这是 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery">jQuery 的类型定义文件</a> 中一段代码（为了方便理解做了一些改动）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 jQuery 需要用到的类型命名空间</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">JQuery</span> &#123;</span><br><span class="line">	<span class="comment">// 定义基本使用的类型</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Selector</span> = <span class="built_in">string</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">TypeOrArray</span>&lt;T&gt; = T | T[];</span><br><span class="line">	<span class="keyword">type</span> htmlString = <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 jQuery 接口，jquery 是一个 包含 Element 的集合</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JQuery</span>&lt;<span class="title class_">TElement</span> <span class="keyword">extends</span> <span class="title class_">Node</span> = <span class="title class_">HTMLElement</span>&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;<span class="title class_">TElement</span>&gt; &#123;</span><br><span class="line">	<span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="title function_">eq</span>(<span class="attr">index</span>: <span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 重载</span></span><br><span class="line">	<span class="title function_">add</span>(<span class="attr">selector</span>: <span class="title class_">JQuery</span>.<span class="property">Selector</span>, <span class="attr">context</span>: <span class="title class_">Element</span>): <span class="variable language_">this</span>;</span><br><span class="line">	<span class="title function_">add</span>(<span class="attr">selector</span>: <span class="title class_">JQuery</span>.<span class="property">Selector</span> | <span class="title class_">JQuery</span>.<span class="property">TypeOrArray</span>&lt;<span class="title class_">Element</span>&gt; | <span class="title class_">JQuery</span>.<span class="property">htmlString</span> | <span class="title class_">JQuery</span>): <span class="variable language_">this</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">children</span>(selector?: <span class="title class_">JQuery</span>.<span class="property">Selector</span>): <span class="variable language_">this</span>;</span><br><span class="line">	<span class="title function_">css</span>(<span class="attr">propertyName</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">	<span class="title function_">html</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对模块 jquery 输出接口</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;jquery&#x27;</span> &#123;</span><br><span class="line">	<span class="comment">// module 中要使用 export = 而不是 export default</span></span><br><span class="line">    <span class="keyword">export</span> = jQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p><code>*.d.ts</code> 编写起来非常简单，经过 TypeScript 良好的静态类型系统洗礼过后，语法学习成本非常低。</p>
<p>我们可以使用 <code>type</code> 用来定义类型变量：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserName</span> = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型赋值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WebSite</span> = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Tsaid</span> = <span class="title class_">WebSite</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>type</code> 其实可以定义各种格式的类型，也可以和其他类型进行组合。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">website</span>: <span class="title class_">WebSite</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">type</span> say = <span class="function">(<span class="params">age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaSaid</span> &#123;</span><br><span class="line">  <span class="attr">website</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">say</span>: <span class="function">(<span class="params">age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用 <code>interface</code> 定义我们的复杂类型，在 TS 中我们也可以直接定义 <code>interface</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">	<span class="title function_">init</span>(): <span class="built_in">void</span></span><br><span class="line">	<span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">string</span>): <span class="built_in">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>interface</code> 和 <code>type</code>(或者说 <code>class</code>) 很像。</p>
<p>但是 <code>type</code> 的含义是定义自定义类型，当 TS 提供给你的基础类型都不满足的时候，可以使用 <code>type</code> 自由组合出你的新类型，而 <code>interface</code> 应该是对外输出的接口。</p>
<p><code>type</code> 不可以被继承，但 <code>interface</code> 可以：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BaseApplication</span> &#123;</span><br><span class="line">	<span class="attr">appId</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Application</span> <span class="keyword">extends</span> <span class="title class_">BaseApplication</span> &#123;</span><br><span class="line">  <span class="title function_">init</span>(): <span class="built_in">void</span></span><br><span class="line">	<span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">string</span>): <span class="built_in">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h2><p><code>declare</code> 可以创建 <code>*.d.ts</code> 文件中的变量，<code>declare</code> 只能作用域最外层：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> tasaid &#123;</span><br><span class="line">  <span class="comment">// 这里不能 declare</span></span><br><span class="line">  <span class="keyword">interface</span> blog &#123;</span><br><span class="line">    <span class="attr">website</span>: <span class="string">&#x27;http://tasaid.com&#x27;</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上顶层的定义都需要使用 <code>declare</code>， <code>class</code> 也是：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>为防止类型重复，使用 <code>namespace</code> 用于划分区域块，分离重复的类型，顶层的 <code>namespace</code> 需要 <code>declare</code> 输出到外部环境，子命名空间不需要 <code>declare</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名空间</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">Models</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> A = <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// 子命名空间</span></span><br><span class="line">  <span class="keyword">namespace</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> A = <span class="built_in">object</span></span><br><span class="line">    <span class="keyword">type</span> B = <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">Models</span>.<span class="property">Config</span>.<span class="property">A</span></span><br></pre></td></tr></table></figure>



<h2 id="组合定义"><a href="#组合定义" class="headerlink" title="组合定义"></a>组合定义</h2><p>上面我们只演示了一些简单的类型组合，生产环境中会包含许多复杂的类型定义，这时候我们就需要各种组合出强大的类型定义：</p>
<h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>有些类型的属性名是动态而未知的，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;10086&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;中国移动&#x27;</span>,</span><br><span class="line">    <span class="attr">website</span>: <span class="string">&#x27;http://www.10086.cn&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;10010&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;中国联通&#x27;</span>,</span><br><span class="line">    <span class="attr">website</span>: <span class="string">&#x27;http://www.10010.com&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;10000&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;中国电信&#x27;</span>,</span><br><span class="line">    <span class="attr">website</span>: <span class="string">&#x27;http://www.189.cn&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用动态属性名来定义类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ChinaMobile</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">website</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ChinaMobileList</span> &#123;</span><br><span class="line">  <span class="comment">// 动态属性</span></span><br><span class="line">  [<span class="attr">phone</span>: <span class="built_in">string</span>]: <span class="title class_">ChinaMobile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型遍历"><a href="#类型遍历" class="headerlink" title="类型遍历"></a>类型遍历</h3><p>当你已知某个类型范围的时候，可以使用 <code>in</code> 和 <code>keyof</code> 来遍历类型，例如上面的 ChinaMobile 例子，我们可以使用 <code>in</code> 来约束属性名必须为三家运营商之一：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ChinaMobilePhones</span> = <span class="string">&#x27;10086&#x27;</span> | <span class="string">&#x27;10010&#x27;</span> | <span class="string">&#x27;10000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ChinaMobile</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">website</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能 type 使用， interface 无法使用</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ChinaMobileList</span> = &#123;</span><br><span class="line">  <span class="comment">// 遍历属性</span></span><br><span class="line">  [phone <span class="keyword">in</span> <span class="title class_">ChinaMobilePhones</span>]: <span class="title class_">ChinaMobile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以用 <code>keyof</code> 来约定方法的参数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> keys = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">appId</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">config</span>: <span class="built_in">object</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="comment">// 参数和值约束范围</span></span><br><span class="line">  set&lt;T <span class="keyword">extends</span> keyof keys&gt;(<span class="attr">key</span>: T, <span class="attr">val</span>: keys[T])</span><br><span class="line">  get&lt;T <span class="keyword">extends</span> keyof keys&gt;(<span class="attr">key</span>: T): keys[T]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/2094b0e190bf5c66045488f3c2cab5e5.png" alt="keyof"></p>
<h2 id="import-导入和-export-导出"><a href="#import-导入和-export-导出" class="headerlink" title="import 导入和 export 导出"></a>import 导入和 export 导出</h2><p>js 中有多种 <code>import</code> 和 <code>export </code>模块的方式，所以在 <code>d.ts</code>  中也对应有着不同的导入导出方式。</p>
<h3 id="导入规则"><a href="#导入规则" class="headerlink" title="导入规则"></a>导入规则</h3><p>在 ts 中不同的 <code>import</code> 语法会决定如何解析这个 module：</p>
<ul>
<li>有类型声明，标准 es module 库：<code>import * as xxxx from &#39;&#39;</code> 或 <code>import xxx from &#39;&#39;</code> 导入</li>
<li>有类型声明，标准 commonjs 库： <code>import xxx = require(&#39;&#39;)</code> 导入</li>
<li>没有类型声明：<code>const xxx = require(&#39;&#39;)</code> 导入（默认导入为 any 类型）</li>
</ul>
<p>同样，js 中不同的 <code>export</code> 语法也对应着不同的声明方式。</p>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>如果 js 是 <code>es6 module</code> 风格的，通过  <code>export default</code> 导出的，经过编译工具编译为 <code>export.default</code> 以后(一般为 babel 或其他工具编译)，则声明文件这样写：</p>
<p>js 源文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">options</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">default</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>d.ts 声明文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出接口声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Options</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明默认函数</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">main</span> (<span class="attr">options</span>: <span class="title class_">Options</span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> main</span><br></pre></td></tr></table></figure>

<p>特点是这样引入(在 <code>tsconfig.json</code> 中没有开启 <code>allowSyntheticDefaultImports</code>  选项的情况下)：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> demo <span class="keyword">from</span> <span class="string">&#x27;demo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Options</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;demo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用默认方法</span></span><br><span class="line"><span class="title function_">demo</span>(&#123; &#125;)</span><br></pre></td></tr></table></figure>


<h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><p>如果 js 是 <code>commonjs</code> 风格的，是通过 <code>module.exports</code> 导出的，则声明文件这样写：</p>
<p>js 源文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>d.ts 声明文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包的声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">main</span> (<span class="attr">options</span>: main.<span class="property">Options</span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包里面的接口通过 namespace 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> main &#123;</span><br><span class="line">  <span class="comment">// 导出接口声明</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Options</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出包默认声明</span></span><br><span class="line"><span class="keyword">export</span> = main</span><br></pre></td></tr></table></figure>

<p>特点是这样引入：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">import</span> demo = <span class="built_in">require</span>(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入接口声明</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Options</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;demo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用默认方法</span></span><br><span class="line"><span class="title function_">demo</span>(&#123; &#125;)</span><br></pre></td></tr></table></figure>


<h3 id="export-xxx"><a href="#export-xxx" class="headerlink" title="export xxx"></a>export xxx</h3><p>如果只是普通的 <code>exports xxx</code> ，经过编译工具编译为 <code>export.xxx</code> 之后，则声明文件相对简单：</p>
<p>js 源文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">options</span>) =&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">func</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>d.ts 声明文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出接口声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Options</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">func</span>: <span class="function">(<span class="params">options: Options</span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>引入方式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入接口声明</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Options</span>, func &#125; <span class="keyword">from</span> <span class="string">&#x27;demo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">func</span>(&#123; &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="集成发布"><a href="#集成发布" class="headerlink" title="集成发布"></a>集成发布</h2><p>有两种主要方式用来发布类型定义文件到 <code>npm</code>：</p>
<ol>
<li>与你的 npm 包捆绑在一起(内置类型定义文件)</li>
<li>发布到 npm 上的 <a target="_blank" rel="noopener" href="https://www.npmjs.com/~types">@types organization</a></li>
</ol>
<p>前者，安装完了包之后会自动检测并识别类型定义文件。<br>后者，则需要通过 <code>npm i @types/xxxx</code> 安装，这就是我们前面所说的 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> ，用于扩展 JS 库的类型声明。</p>
<h3 id="内置类型定义文件"><a href="#内置类型定义文件" class="headerlink" title="内置类型定义文件"></a>内置类型定义文件</h3><p>内置类型定义就是把你的类型定义文件和 npm 包一起发布，一般来说，类型定义文件都放在包根目录的 <code>types</code> 目录里，例如 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/tree/v2.5.2/types">vue</a>：</p>
<p>如果你的包有一个主 <code>.js</code> 文件，需要在 <code>package.json</code> 里指定主类型定义文件。</p>
<p>设置 <code>types</code> 或 <code>typeings</code> 属性指向捆绑在一起的类型定义文件。 例如包目录如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── lib</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   └── main.d.ts <span class="comment"># 类型定义文件</span></span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageage.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;demo project&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">    <span class="comment">// 定义主类型定义文件</span></span><br><span class="line">    <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果主类型定义文件名是 <code>index.d.ts</code> 并且位置在包的根目录里，就不需要使用 <code>types</code> 属性指定了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── lib</span><br><span class="line">│   └── main.js</span><br><span class="line">├── index.d.ts <span class="comment"># 类型定义文件</span></span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>如果你发的包中，<code>package.json</code> 中使用了 <code>files</code> 字段的话（<code>npm</code> 会根据 <code>files</code> 配置的规则决定发布哪些文件），则需要手动把类型定义文件加入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageage.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.d.ts&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果只发二级目录的话，把类型定义文件放到对应的二级目录下即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">App</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;demo/app&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="发布到-types-organizatio"><a href="#发布到-types-organizatio" class="headerlink" title="发布到 @types organizatio"></a>发布到 @types organizatio</h3><p>发布到 <code>@types organizatio</code> 的包表示源包没有包含类型定义文件，第三方&#x2F;或原作者定义好类型定义文件之后，发布到 <a target="_blank" rel="noopener" href="https://www.npmjs.com/~types">@types</a> 中。例如 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/@types/express">@types&#x2F;express</a>。</p>
<p>根据 <code>DefinitelyTyped</code> 的规则，和编辑器(和插件) 自动检测静态类型。</p>
<p><a target="_blank" rel="noopener" href="https://www.npmjs.com/~types">@types</a> 下面的包是从 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 里自动发布的，通过 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/types-publisher">types-publisher</a> 工具。 </p>
<p>如果想让你的包发布为 @types 包，需要提交一个 pull request 到 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a>。 </p>
<p>在这里查看详细信息 <a target="_blank" rel="noopener" href="http://definitelytyped.org/guides/contributing.html">contribution guidelines page</a>。</p>
<p>如果你正在使用 TypeScript，而使用了一些 JS 包并没有对应的类型定义文件，可以编写一份然后提交到 <code>@types</code>。</p>
<p>赠人玫瑰，手留余香。</p>
<p>发布到 <code>@types organizatio</code> 的包可以通过 <a target="_blank" rel="noopener" href="https://microsoft.github.io/TypeSearch/">TypeSearch</a> 搜索检索，使用 <code>npm install --save-dev @types/xxxx</code> 安装：</p>
<p><img src="//static.tasaid.com/blogs/26a7416bf2b8b2eebb74a32d2015eed3.png" alt="@types"></p>
<p>更多细节请参阅 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="为第三方包声明类型"><a href="#为第三方包声明类型" class="headerlink" title="为第三方包声明类型"></a>为第三方包声明类型</h3><p>通常来说，如果这份类型定义文件是 JS 库自带的，那么我们可以直接导出模块：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> = <span class="title class_">User</span></span><br></pre></td></tr></table></figure>

<p>而如果这份类型定义文件不是 JS 库自带的，而是第三方的，则需要使用 <code>module</code> 进行关联。</p>
<p>例如 <code>jquery</code> 发布的 npm 包中不包含 <code>*.d.ts</code> 类型定义文件，<code>jquery</code> 的类型定义文件发布在了 <code>@types/jquery</code>，所以类型定义文件中导出类型的时候，需要关联模块 <code>jquery</code>，意思就是我专门针对这个包做的类型定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> jQuery &#123;&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;jquery&#x27;</span> &#123;</span><br><span class="line">    <span class="comment">// 因为 jquery 使用的是 commonjs module，所以需要用 export 导出</span></span><br><span class="line">    <span class="comment">// es6 module 可以使用 export default 导出</span></span><br><span class="line">    <span class="keyword">export</span> = jQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而解决了一些主流的 JS 库发布的 <code>npm</code> 包中没有类型定义文件，但是我们可以用第三方类型定义文件为这些库补充类型。</p>
<h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><p>经过一系列探索，个人比较推荐下面的编写风格，先看目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">types</span><br><span class="line">├── application.d.ts</span><br><span class="line">├── config.d.ts</span><br><span class="line">├── index.d.ts <span class="comment"># 入口模块</span></span><br><span class="line">└── user.d.ts</span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/b53c668059b6fc2f87dda190536d04f6.png"></p>
<p>入口模块主要做这些事情：</p>
<ol>
<li>定义命名空间</li>
<li>导出和聚合子模块</li>
</ol>
<p>主出口文件 <code>index.d.ts</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">UserModel</span> <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">AppModel</span> <span class="keyword">from</span> <span class="string">&#x27;./application&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ConfigModel</span> <span class="keyword">from</span> <span class="string">&#x27;./config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">Models</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">UserModel</span>.<span class="property">User</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Application</span> = <span class="title class_">AppModel</span>.<span class="property">Application</span>;</span><br><span class="line">  <span class="comment">// 利用 as 抹平争议性变量名</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Config</span> = <span class="title class_">ConfigModel</span>.<span class="property">Config</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子模块无需定义命名空间，这样外部环境 (<code>types</code> 文件夹之外) 则无法获取子模块类型，达到了类型封闭的效果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/d4d0a06d/" data-id="cloizszuv0005xww622382tfe" data-title="JavaScript 和 TypeScript 交叉口 —— 类型定义文件(*.d.ts)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/从JavaScript到TypeScript6-Vue引入TypeScript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/7e42a592/" class="article-date">
  <time class="dt-published" datetime="2017-10-11T15:31:00.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/7e42a592/">从 JavaScript 到 TypeScript 6 - Vue 引入 TypeScript</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>随着应用的庞大，项目中 JavaScript 的代码也会越来越臃肿，这时候许多 JavaScript 的语言弊端就会愈发明显，而 TypeScript 的出现，就是着力于解决 JavaScript 语言天生的弱势：静态类型。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<p>这篇文章首发于我的个人博客 《<a target="_blank" rel="noopener" href="http://tasaid.com/">听说</a>》，系列目录：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011231943.html">从 JavaScript 到 TypeScript 1 - 什么是 TypeScript</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232755.html">从 JavaScript 到 TypeScript 2 - 基础特性和类型推导</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232938.html">从 JavaScript 到 TypeScript 3 - 引入和编译</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233014.html">从 JavaScript 到 TypeScript 4 - 装饰器和反射</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233051.html">从 JavaScript 到 TypeScript 5 - express 路由进化</a>》</li>
<li>《从 JavaScript 到 TypeScript 6 - vue 引入 TypeScript》</li>
</ul>
<p>在上一篇文章 《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233051.html">从 JavaScript 到 TypeScript 5 - express 路由进化</a>》 我们介绍了如何使用装饰器将 <code>express</code> 的 <code>router</code> 实现的更加优雅。在这篇文章中，我们将介绍如何在 Vue 中引入 TypeScript。</p>
<h2 id="Vue-引入-TypeScript"><a href="#Vue-引入-TypeScript" class="headerlink" title="Vue 引入 TypeScript"></a>Vue 引入 TypeScript</h2><p>Vue 在 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/typescript.html#main">官方文档中有一节简单的介绍了如何引入 TypeScript</a>，可惜文档太过简单，真正投入生产还有许多的细节没有介绍。</p>
<p>我们对此进行了一系列探索，最后我们的风格是这样的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Prop</span>, <span class="title class_">Vue</span>, <span class="title class_">Watch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">State</span>, <span class="title class_">Action</span>, <span class="title class_">Mutation</span>, <span class="keyword">namespace</span> &#125; from &#x27;vuex-class&#x27;</span><br><span class="line">import <span class="title class_">Toast</span> from &#x27;components/<span class="title class_">Toast</span>.vue&#x27;</span><br><span class="line"></span><br><span class="line">const userState = <span class="keyword">namespace</span>(&#x27;business/user&#x27;, <span class="title class_">State</span>)</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">Toast</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="comment">// data</span></span><br><span class="line">  title = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123; <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// store</span></span><br><span class="line">  <span class="meta">@userState</span> userId</span><br><span class="line"></span><br><span class="line">  <span class="comment">// computed</span></span><br><span class="line">  get name (): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">title</span> + <span class="variable language_">this</span>.<span class="property">text</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// watch</span></span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">  onChangeText () &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hooks</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体来说，Vue 引入 TypeScript 可以用到这些生态库：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-class-component">vue-class-component</a>：强化 Vue 组件，使用 TypeScript&#x2F;装饰器 增强 Vue 组件</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kaorun343/vue-property-decorator">vue-property-decorator</a>：在 <code>vue-class-component</code> 上增强更多的结合 Vue 特性的装饰器</li>
<li><a target="_blank" rel="noopener" href="https://github.com/ktsn/vuex-class">vuex-class</a>：在 <code>vue-class-component</code> 提供 <code>Vuex</code> 的绑定</li>
<li><a target="_blank" rel="noopener" href="https://github.com/snaptopixel/vuex-ts-decorators">vuex-ts-decorators</a>：让 <code>Vuex</code> 和 TypeScript 结合</li>
</ul>
<p>下面我们一步步来介绍 Vue 如何引入 TypeScript</p>
<h2 id="webpack-和-tsconfig-json-配置"><a href="#webpack-和-tsconfig-json-配置" class="headerlink" title="webpack 和 tsconfig.json 配置"></a>webpack 和 tsconfig.json 配置</h2><p>TypeScript 为 Webpack 提供了 <code>ts-loader</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ts-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>webpack 配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">appendTsSuffixTo</span>: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ts-loader</code> 会检索当前目录下的 <code>tsconfig.json</code> 文件，如果找不到会一层层往上找。</p>
<p>这里有一份参考的 <code>tsconfig.json</code> 配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 编译选项</span></span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出目录</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./output&quot;</span>,</span><br><span class="line">    <span class="comment">// 是否包含可以用于 debug 的 sourceMap</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 以严格模式解析</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 采用的模块系统</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="comment">// 如何处理模块</span></span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="comment">// 编译输出目标 ES 版本</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">    <span class="comment">// 允许从没有设置默认导出的模块中默认导入</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 将每个文件作为单独的模块</span></span><br><span class="line">    <span class="string">&quot;isolatedModules&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 启用设计类型元数据（用于反射）</span></span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 在表达式和声明上有隐含的any类型时报错</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不是函数的所有返回路径都有返回值时报错。</span></span><br><span class="line">    <span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 从 tslib 导入外部帮助库: 比如__extends，__rest等</span></span><br><span class="line">    <span class="string">&quot;importHelpers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 编译过程中打印文件名</span></span><br><span class="line">    <span class="string">&quot;listFiles&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 移除注释</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;suppressImplicitAnyIndexErrors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 允许编译javascript文件</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定特殊模块的路径</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;jquery&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 编译过程中需要引入的库文件的列表</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;dom&quot;</span>,</span><br><span class="line">      <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">      <span class="string">&quot;es2015.promise&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 TypeScript 默认并不支持 <code>*.vue</code> 后缀的文件，所以在 vue 项目中引入的时候需要创建一个 <code>vue-shims.d.ts</code> 文件，放在项目项目对应使用目录下，例如 <code>src/vue-shims.d.ts</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*.vue&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思是告诉 TypeScript <code>*.vue</code> 后缀的文件可以交给 <code>vue</code> 模块来处理。</p>
<p>而在代码中导入 <code>*.vue</code> 文件的时候，需要写上 <code>.vue</code> 后缀。原因还是因为 TypeScript 默认只识别 <code>*.ts</code> 文件，不识别 <code>*.vue</code> 文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;components/component.vue&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h2><p><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-class-component">vue-class-component</a>  对 Vue 组件进行了一层封装，让 Vue 的组件语法在结合了 TypeScript 语法之后更加扁平化：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>msg: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>computed msg: &#123;&#123; computedMsg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  @<span class="title class_">Component</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 初始化数据</span></span></span><br><span class="line"><span class="language-javascript">    msg = <span class="number">123</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 声明周期钩子</span></span></span><br><span class="line"><span class="language-javascript">    mounted () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">greet</span>()</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 计算属性</span></span></span><br><span class="line"><span class="language-javascript">    get computedMsg () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="string">&#x27;computed &#x27;</span> + <span class="variable language_">this</span>.<span class="property">msg</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 方法</span></span></span><br><span class="line"><span class="language-javascript">    greet () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;greeting: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">msg</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码和下面没有引入 <code>vue-class-component</code> 的语法一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明周期钩子</span></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">greet</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算属性</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    computedMsg () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;computed &#x27;</span> + <span class="variable language_">this</span>.<span class="property">msg</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    greet () &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;greeting: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">msg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h2><p><a target="_blank" rel="noopener" href="https://github.com/kaorun343/vue-property-decorator">vue-property-decorator</a> 是在 <code>vue-class-component</code> 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p>
<ul>
<li><code>@Emit</code></li>
<li><code>@Inject</code></li>
<li><code>@Model</code></li>
<li><code>@Prop</code></li>
<li><code>@Provide</code></li>
<li><code>@Watch</code></li>
<li><code>@Component</code> (从 <code>vue-class-component</code> 继承)</li>
</ul>
<p>这里仅列举常用的 <code>@Prop/@Watch/@Component</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Emit</span>, <span class="title class_">Inject</span>, <span class="title class_">Model</span>, <span class="title class_">Prop</span>, <span class="title class_">Provide</span>, <span class="title class_">Vue</span>, <span class="title class_">Watch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Prop</span>()</span><br><span class="line">  <span class="attr">propA</span>: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123; <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span> &#125;)</span><br><span class="line">  <span class="attr">propB</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>([<span class="title class_">String</span>, <span class="title class_">Boolean</span>])</span><br><span class="line">  <span class="attr">propC</span>: <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">  <span class="attr">propD</span>: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">&#x27;child&#x27;</span>)</span><br><span class="line">  <span class="title function_">onChildChanged</span>(<span class="params">val: <span class="built_in">string</span>, oldVal: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">checked</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="attr">propA</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">propB</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propC</span>: [<span class="title class_">String</span>, <span class="title class_">Boolean</span>],</span><br><span class="line">    <span class="attr">propD</span>: &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">onChildChanged</span>(<span class="params">val, oldVal</span>) &#123; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;child&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="string">&#x27;onChildChanged&#x27;</span>,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vuex-class"><a href="#vuex-class" class="headerlink" title="vuex-class"></a>vuex-class</h2><p><a target="_blank" rel="noopener" href="https://github.com/ktsn/vuex-class">vuex-class</a> 在 <code>vue-class-component</code> 上，提供了 <code>Vuex</code> 的绑定的装饰器语法。</p>
<p>我们编写一个简单的 Vuex store：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vuex</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;linkFly&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">demo</span>: &#123;</span><br><span class="line">      <span class="comment">// 带命名空间</span></span><br><span class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">mutations</span>: &#123;</span><br><span class="line">        increment (state, n?: <span class="built_in">number</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (n != <span class="literal">null</span> ) </span><br><span class="line">            state.<span class="property">count</span> = n</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">            state.<span class="property">count</span>++</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">actions</span>: &#123;</span><br><span class="line">        increment (&#123; commit &#125;) &#123;</span><br><span class="line">          commit.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div class=&quot;app&quot;&gt;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>vuex-class</code> 之后：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">State</span>,</span><br><span class="line">  <span class="title class_">Getter</span>,</span><br><span class="line">  <span class="title class_">Action</span>,</span><br><span class="line">  <span class="title class_">Mutation</span>,</span><br><span class="line">  <span class="keyword">namespace</span></span><br><span class="line">&#125; from &#x27;vuex-class&#x27;</span><br><span class="line"></span><br><span class="line">const <span class="title class_">ModuleState</span> = <span class="keyword">namespace</span>(&#x27;demo&#x27;, <span class="title class_">State</span>)</span><br><span class="line">const <span class="title class_">ModuleAction</span> = <span class="keyword">namespace</span>(&#x27;demo&#x27;, <span class="title class_">Action</span>)</span><br><span class="line">const <span class="title class_">ModuleMutation</span> = <span class="keyword">namespace</span>(&#x27;demo&#x27;, <span class="title class_">Mutation</span>)</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line">export class <span class="title class_">MyComp</span> extends <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@ModuleState</span>(<span class="string">&#x27;count&#x27;</span>) count</span><br><span class="line">  <span class="meta">@ModuleAction</span> increment</span><br><span class="line">  <span class="meta">@ModuleMutation</span>(<span class="string">&#x27;increment&#x27;</span>) mutationIncrement</span><br><span class="line">  <span class="meta">@State</span> name</span><br><span class="line">  </span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> <span class="comment">// -&gt; store.state.name =&gt; linkFly</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> <span class="comment">// -&gt; store.state.demo.count =&gt; 0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">increment</span>() <span class="comment">// -&gt; store.dispatch(&#x27;demo/increment&#x27;)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">mutationIncrement</span>(<span class="number">2</span>) <span class="comment">// -&gt; store.commit(&#x27;demo/increment&#x27;, 2)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vuex-ts-decorators"><a href="#vuex-ts-decorators" class="headerlink" title="vuex-ts-decorators"></a>vuex-ts-decorators</h2><p>由于使用 <code>vue-class-component</code>，在 Vue 组件中我们已经感受到了装饰器的强大语法糖，于是我们还希望在 Vuex Store 中也能使用装饰器的语法： <a target="_blank" rel="noopener" href="https://github.com/snaptopixel/vuex-ts-decorators">vuex-ts-decorators</a> 就是干这个事情的。</p>
<p><code>vuex-ts-decorators</code> 可以让你结合装饰器来编写 Vuex Store。</p>
<p>由于 <code>vuex-ts-decorators</code> 提供的包是未经编译的 <code>*.ts</code> 代码，如果你排除了 <code>node_modules</code> 的编译，则需要在 <code>ts-loader</code> 中单独加上对它的编译：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">  <span class="comment">// 加上对 vuex-ts-decorators 这个包的编译</span></span><br><span class="line">  <span class="attr">exclude</span>: [<span class="regexp">/node_modules/</span>, <span class="regexp">/node_modules\/(?!vuex-ts-decorators)/</span>],</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">appendTsSuffixTo</span>: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然后就可以愉快使用它来编写 Vuex Store 了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable language_">module</span>, action, mutation &#125; <span class="keyword">from</span> <span class="string">&#x27;mfe-vuex-ts-decorators&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> actions = &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mutations = &#123;</span><br><span class="line">  <span class="comment">// 定义对应 mutations 的参数类型</span></span><br><span class="line">  <span class="attr">incrementMutation</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypedDispatch</span> = &lt;T <span class="keyword">extends</span> keyof actions&gt;<span class="function">(<span class="params"><span class="keyword">type</span>: T, value?: actions[T]</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>[]&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypedCommit</span> = &lt;T <span class="keyword">extends</span> keyof mutations&gt;<span class="function">(<span class="params"><span class="keyword">type</span>: T, value?: mutations[T]</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@module</span>(&#123;</span><br><span class="line">  <span class="attr">store</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">  <span class="comment">// 用于类型检查，使 commit/dispatch 的方法可以找到并且可以被类型检查</span></span><br><span class="line">  <span class="attr">dispatch</span>: <span class="title class_">TypedDispatch</span></span><br><span class="line">  <span class="attr">commit</span>: <span class="title class_">TypedCommit</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">countGetter</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// action</span></span><br><span class="line">  <span class="meta">@action</span></span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">commit</span>(<span class="string">&#x27;incrementMutation&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutation</span></span><br><span class="line">  <span class="meta">@mutation</span></span><br><span class="line">  <span class="title function_">incrementMutation</span>(<span class="params">payload?: mutations[<span class="string">&#x27;incrementMutation&#x27;</span>]</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="literal">null</span> ) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = payload</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vuex-ts-decorators</code> 文档没有提及 <code>@module</code> 装饰器的参数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@module</span>(&#123;</span><br><span class="line">  store?: <span class="built_in">boolean</span> = <span class="literal">false</span>; <span class="comment">// 是否自动挂载到 Vuex Store 下，如果为 false 则</span></span><br><span class="line">  modules?: <span class="title class_">Object</span>; <span class="comment">// 子 modules</span></span><br><span class="line">  namespaced?: <span class="built_in">boolean</span>; <span class="comment">// 命名空间</span></span><br><span class="line">&#125; | (<span class="built_in">any</span>, &#123; <span class="attr">decorators</span>: <span class="built_in">any</span> &#125; =&gt; <span class="built_in">any</span>)) <span class="comment">// 也可以使用函数</span></span><br></pre></td></tr></table></figure>


<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>vuex-ts-decorators</code> 这个项目目前最后一次更新时间是 2017 年 2 月 21 日，原作者说自己正在开发对应的新项目，这个项目已经不再维护，但是目前还没有看到新项目的进展。</p>
<p>但可以肯定的是，原作者已经不再维护 <code>vuex-ts-decorators</code> 这个项目。</p>
<p>我们的做法是在这个项目上重新 fork 一个新项目，并且修正了遇到的隐藏 bug。后续我们会自己维护这个项目。(fork 到了内部项目中，后续在这个项目基础上进行二次开发，到时候会公布出来，当然，其实它的功能很简单完全可以自己开发一个)</p>
<p>目前已知 bug：</p>
<p>当使用 <code>@module(&#123; store: false &#125;)</code> 后，被包装的 class 会返回处理后的 Vuex Store，结构为： <code>&#123; state: any, getters: any, modules: any, actions: any, mutations: any  &#125;</code>。  </p>
<p>如果最后 <code>new Vuex.Store(&#123; options: object &#125;)</code> 的时候传递的不是 <code>@module</code> 包装后的 Vuex Store(例如对这个 Vuex Store 做了一层深拷贝)，则会导致 <code>mutations</code> 中 this 丢失。</p>
<p>bug 点在 <a target="_blank" rel="noopener" href="https://github.com/snaptopixel/vuex-ts-decorators/blob/v0.0.7/src/mutation.ts">这一行</a>，处理办法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">mutations</span>[name] = <span class="function">(<span class="params">state: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  method.<span class="title function_">apply</span>(store.<span class="property">state</span>, args); </span><br><span class="line">  <span class="comment">// 替换为</span></span><br><span class="line">  method.<span class="title function_">apply</span>(state, args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因是因为 <code>vuex-ts-decorators</code> 一直在自己内部引用着生成的 Vuex Store，如果最终 <code>new Vuex.Store()</code>  的时候没有传递它自己生成的 Vuex Store 就会导致引用不正确。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>围绕 <code>vue-class-component</code> 展开的生态圈，如同一把利剑，通过各种装饰器，能够结合 TypeScript 将 Vue 武装的更加强大。在这篇文章发布之际，很巧的是：<a target="_blank" rel="noopener" href="https://medium.com/the-vue-point/upcoming-typescript-changes-in-vue-2-5-e9bd7e2ecf08">Vue 作者尤雨溪也宣布在 Vue 2.5 以后将全面支持 TypeScript</a>(译文看<a target="_blank" rel="noopener" href="https://juejin.im/post/59daf2df5188250b40076d73">这里</a>)，并且声明<strong>Vue 将尽力做到和 vue-class-component 兼容</strong>。</p>
<p>前端的场景已经不再像当年一样简单的切图、画简单的样式和写简单的脚本。应用越来越庞大，需求越来越复杂。TypeScript 有一个很好的切入点：从语言的角度解决了大型 Web 应用的静态类型约束痛点。</p>
<p>相信随着时间的推移，会有越来越多的人和框架加入到 TypeScript 大军。</p>
<p>至此，我们的 《从 JavaScript 到 TypeScript》 系列文章已经结束。最后，Welcome to TypeScript!</p>
<p>&nbsp;</p>
<p>TypeScript 中文网：<a target="_blank" rel="noopener" href="https://tslang.cn/">https://tslang.cn/</a> </p>
<p>TypeScript 视频教程：《<a target="_blank" rel="noopener" href="https://nodelover.me/course/ts-basic">TypeScript 精通指南</a>》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/7e42a592/" data-id="cloizszv3001qxww641p6dujj" data-title="从 JavaScript 到 TypeScript 6 - Vue 引入 TypeScript" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/从JavaScript到TypeScript4-装饰器和反射" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/e6877d92/" class="article-date">
  <time class="dt-published" datetime="2017-10-11T15:30:00.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/e6877d92/">从 JavaScript 到 TypeScript 4 - 装饰器和反射</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>随着应用的庞大，项目中 JavaScript 的代码也会越来越臃肿，这时候许多 JavaScript 的语言弊端就会愈发明显，而 TypeScript 的出现，就是着力于解决 JavaScript 语言天生的弱势：静态类型。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<p>这篇文章首发于我的个人博客 《<a target="_blank" rel="noopener" href="http://tasaid.com/">听说</a>》，系列目录：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011231943.html">从 JavaScript 到 TypeScript 1 - 什么是 TypeScript</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232755.html">从 JavaScript 到 TypeScript 2 - 基础特性和类型推导</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232938.html">从 JavaScript 到 TypeScript 3 - 引入和编译</a>》</li>
<li>《从 JavaScript 到 TypeScript 4 - 装饰器和反射》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233051.html">从 JavaScript 到 TypeScript 5 - express 路由进化</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233132.html">从 JavaScript 到 TypeScript 6 - vue 引入 TypeScript</a>》</li>
</ul>
<p>在上一篇文章 《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232938.html">从 JavaScript 到 TypeScript 3 - 引入和编译</a>》 我们简单介绍了 TypeScript 的引入和编译，在这篇文章中，我们会讨论 ECMAScript 的新特性，为后续的内容做点铺垫。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在了解装饰器之前，我们先看一段代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, id: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeName (<span class="attr">newName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码声明了一个 Class 为 <code>User</code>，<code>User</code> 提供了一个实例方法 <code>changeName()</code> 用来修改字段 <code>name</code> 的值。</p>
<p>现在我们要在修改 <code>name</code> 之前，先对 <code>newName</code> 做校验，判断如果 <code>newName</code> 的值为空字符串，就抛出异常。</p>
<p>按照我们过去的做法，我们会修改 <code>changeName()</code> 函数，或者提供一个 <code>validaName()</code> 方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, id: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 验证 Name</span></span><br><span class="line">  validateName (<span class="attr">newName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newName)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;name is invalid&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  changeName (<span class="attr">newName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 newName 为空字符串，则会抛出异常</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">validateName</span>(newName)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们新编写的 <code>validateName()</code>，侵入到了 <code>changeName()</code> 的逻辑中。如此带来一个弊端：</p>
<ol>
<li>我们不知道 <code>changeName()</code> 里面可能还包含了什么样的隐性逻辑</li>
<li><code>changeName()</code> 被扩展后逻辑不清晰</li>
</ol>
<p>然后我们把调用时机从 <code>changeName()</code> 中抽出来，先调用 <code>validateName()</code>，再调用 <code>changeName()</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;linkFly&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (user.<span class="title function_">validateName</span>(<span class="string">&#x27;tasaid&#x27;</span>)) &#123;</span><br><span class="line">  user.<span class="title function_">changeName</span>(<span class="string">&#x27;tasaid&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面的问题 1 仍然没有被解决，调用方代码变的十分啰嗦。那么有没有更好的方式来表现这层逻辑呢？</p>
<p>装饰器就用来解决这个问题：”无侵入式” 的增强。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>顾名思义，”装饰器” (也叫 “注解”)就是对一个 <strong>类&#x2F;方法&#x2F;属性&#x2F;参数</strong> 的装饰。它是对这一系列代码的增强，并且通过自身描述了被装饰的代码可能存在的行为改变。</p>
<p>简单来说，装饰器就是对代码的描述。</p>
<p>由于装饰器是实验性特性，所以要在 <code>tsconfig.json</code> 里启用这个实验性特性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 支持装饰器</span></span><br><span class="line">        <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>钢铁侠托尼·史塔克只是一个有血有肉的人，而他的盔甲让他成为了钢铁侠，盔甲就是对托尼·史塔克的装饰(增强)。</p>
<p>我们使用装饰器修改一下上面的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个装饰器，第三个参数是 &quot;成员的属性描述符&quot;，如果代码输出目标版本(target)小于 ES5 返回值会被忽略。</span></span><br><span class="line"><span class="keyword">const</span> validate = <span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存原来的方法</span></span><br><span class="line">  <span class="keyword">let</span> method = descriptor.<span class="property">value</span></span><br><span class="line">  <span class="comment">// 重写原来的方法</span></span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params">newValue: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 检查是否是空字符串</span></span><br><span class="line">    <span class="keyword">if</span> (!newValue) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;name is invalid&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则调用原来的方法</span></span><br><span class="line">      method.<span class="title function_">call</span>(<span class="variable language_">this</span>, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, id: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用装饰器</span></span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  changeName (<span class="attr">newName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，<code>changeName</code> 的逻辑没有任何改变，但其实它的行为已经通过装饰器 <code>@validate</code> 增强。</p>
<p>这就是装饰器的作用。装饰器可以用很直观的方式来描述代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@validateString</span></span><br><span class="line">  set name (<span class="meta">@required</span> <span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h2><p>装饰器的执行时机如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个装饰器工厂，在外面使用 @god() 的时候就会调用这个工厂</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">god</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`god(): evaluated <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">  <span class="comment">// 这是装饰器，在 User 生成之后会执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;god(): called&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="meta">@god</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">  test () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">god(): evaluated test</span><br><span class="line">god(): called</span><br></pre></td></tr></table></figure>


<p>我们也可以直接声明一个装饰器来使用（要注意和装饰器工厂的区别）：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">god</span>(<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;god(): called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">// 注意这里不是 @god()，没有 ()</span></span><br><span class="line">  <span class="meta">@god</span></span><br><span class="line">  test () &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器全家族"><a href="#装饰器全家族" class="headerlink" title="装饰器全家族"></a>装饰器全家族</h2><p>装饰器家族有 4 种装饰形式，<strong>注意，装饰器能装饰在类、方法、属性和参数上，但不能只装饰在函数上！</strong></p>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sealed</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法装饰器表达式会在运行时当作函数被调用，传入下列 <strong>3个参数</strong>：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
<li>成员的属性描述符 <code>&#123;value: any, writable: boolean, enumerable: boolean, configurable: boolean&#125;</code></li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">god</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">    <span class="comment">// target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</span></span><br><span class="line">    <span class="comment">// propertyKey: 成员的名字</span></span><br><span class="line">    <span class="comment">// descriptor: 成员的属性描述符 &#123;value: any, writable: boolean, enumerable: boolean, configurable: boolean&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="meta">@god</span>(<span class="string">&#x27;tasaid.com&#x27;</span>)</span><br><span class="line">  sayHello () &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>和函数装饰器一样，只不过是装饰于访问器上的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">god</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">    <span class="comment">// target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</span></span><br><span class="line">    <span class="comment">// propertyKey: 成员的名字</span></span><br><span class="line">    <span class="comment">// descriptor: 成员的属性描述符 &#123;value: any, writable: boolean, enumerable: boolean, configurable: boolean&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 装饰在访问器上</span></span><br><span class="line">  <span class="meta">@god</span>(<span class="string">&#x27;tasaid.com&#x27;</span>)</span><br><span class="line">  get name () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>属性装饰器表达式会在运行时当作函数被调用，传入下列 <strong>2个参数</strong>：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">god</span>(<span class="params">target, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</span></span><br><span class="line">  <span class="comment">// propertyKey: 成员的名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="meta">@god</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>参数装饰器表达式会在运行时当作函数被调用，传入下列 3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
<li>参数在函数参数列表中的索引</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> required = <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, parameterIndex: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</span></span><br><span class="line">  <span class="comment">// propertyKey: 成员的名字</span></span><br><span class="line">  <span class="comment">// parameterIndex: 参数在函数参数列表中的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> _name : <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params"><span class="meta">@required</span> name : <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如上面 <code>validate</code> 的例子可以用在参数装饰器上</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个私有 key</span></span><br><span class="line"><span class="keyword">const</span> requiredMetadataKey = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;router:required&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义参数装饰器，大概思路就是把要校验的参数索引保存到成员中</span></span><br><span class="line"><span class="keyword">const</span> required = <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, parameterIndex: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 属性附加</span></span><br><span class="line">  <span class="keyword">const</span> rules = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(requiredMetadataKey, target, propertyKey) || []</span><br><span class="line">  rules.<span class="title function_">push</span>(parameterIndex)</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(requiredMetadataKey, rules, target, propertyKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个方法装饰器，从成员中获取要校验的参数进行校验</span></span><br><span class="line"><span class="keyword">const</span> validateEmptyStr = <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存原来的方法</span></span><br><span class="line">  <span class="keyword">let</span> method = descriptor.<span class="property">value</span></span><br><span class="line">  <span class="comment">// 重写原来的方法</span></span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="comment">// 看看成员里面有没有存的私有的对象</span></span><br><span class="line">    <span class="keyword">const</span> rules = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(requiredMetadataKey, target, propertyKey) <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line">    <span class="keyword">if</span> (rules &amp;&amp; rules.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 检查私有对象的 key</span></span><br><span class="line">      rules.<span class="title function_">forEach</span>(<span class="function"><span class="params">parameterIndex</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对应索引的参数进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (!args[parameterIndex]) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`arguments<span class="subst">$&#123;parameterIndex&#125;</span> is invalid`</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, id: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法装饰器做校验</span></span><br><span class="line">  <span class="meta">@validateEmptyStr</span></span><br><span class="line">  changeName (<span class="meta">@required</span> <span class="attr">newName</span>: <span class="built_in">string</span>) &#123; <span class="comment">// 参数装饰器做描述</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/f5cc17abfcb4ecdc20ab0b9622704a28.jpeg" alt="运行代码"></p>
<h2 id="元数据反射"><a href="#元数据反射" class="headerlink" title="元数据反射"></a>元数据反射</h2><p>反射，就是在运行时动态获取一个对象的一切信息：方法&#x2F;属性等等，特点在于动态<strong>类型反推导</strong>。在 TypeScript 中，反射的原理是通过设计阶段对对象注入元数据信息，在运行阶段读取注入的元数据，从而得到对象信息。</p>
<p>反射可以获取对象的：</p>
<ul>
<li>对象的类型</li>
<li>成员&#x2F;静态属性的信息(类型)</li>
<li>方法的参数类型、返回类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;linkFly&#x27;</span></span><br><span class="line"></span><br><span class="line">  say (<span class="attr">myName</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;myName&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如上面的例子，在 TypeScript 中可以获取到这些信息：</p>
<ul>
<li>Class Name 为 <code>User</code></li>
<li><code>User</code> 有一个属性名为 <code>name</code>，有一个方法 <code>say()</code></li>
<li>属性 <code>name</code> 是 <code>string</code> 类型的，且值为 <code>linkFly</code></li>
<li>方法 <code>say()</code> 接受一个 <code>string</code> 类型的参数，<strong>在 TypeScript 中，参数名是获取不到的</strong></li>
<li>方法 <code>say()</code> 返回类型为 <code>string</code></li>
</ul>
<p>TypeScript 结合自身静态类型语言的特点，为使用了装饰器的代码声明注入了 3 组元数据：</p>
<ul>
<li><code>design:type</code>: 成员类型</li>
<li><code>design:paramtypes</code>: 成员所有参数类型</li>
<li><code>design:returntype</code>: 成员返回类型</li>
</ul>
<p>由于元数据反射也是实验性 API，所以要在 <code>tsconfig.json</code> 里启用这个实验性特性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">        <span class="comment">// 支持装饰器</span></span><br><span class="line">        <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 装饰器元数据</span></span><br><span class="line">        <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后安装 <code>reflect-metadata</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>

<p>这样在装饰器中，就可以访问到由 TypeScript 注入的基本信息元数据：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meta = <span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取成员类型</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">type</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:type&#x27;</span>, target, propertyKey)</span><br><span class="line">  <span class="comment">// 获取成员参数类型</span></span><br><span class="line">  <span class="keyword">let</span> paramtypes = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:paramtypes&#x27;</span>, target, propertyKey)</span><br><span class="line">  <span class="comment">// 获取成员返回类型</span></span><br><span class="line">  <span class="keyword">let</span> returntype = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:returntype&#x27;</span>, target, propertyKey)</span><br><span class="line">  <span class="comment">// 获取所有元数据 key (由 TypeScript 注入)</span></span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">getMetadataKeys</span>(target, propertyKey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(keys) <span class="comment">// [ &#x27;design:returntype&#x27;, &#x27;design:paramtypes&#x27;, &#x27;design:type&#x27; ]</span></span><br><span class="line">  <span class="comment">// 成员类型</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">type</span>) <span class="comment">// Function</span></span><br><span class="line">  <span class="comment">// 参数类型</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(paramtypes) <span class="comment">// [String]</span></span><br><span class="line">  <span class="comment">// 成员返回类型</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(returntype) <span class="comment">// String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">// 使用这个装饰器就可以反射出成员详细信息</span></span><br><span class="line">  <span class="meta">@meta</span></span><br><span class="line">  say (<span class="attr">myName</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;myName&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Java 和 C# 由于是强类型编译型语言，所以反射就成了它们动态反推导数据类型的一个重要特性。</p>
<p>目前来说，JavaScript 因为其动态性，所以本身就包含了一些反射的特点：</p>
<ul>
<li>遍历对象内所有属性</li>
<li>判断数据类型</li>
</ul>
<p>TypeScript 补充了基础的类型元数据，只不过还是有些地方不够完善：在 TypeScript 中，参数名通过反射是获取不到的。</p>
<p>为什么获取不到呢？因为 JavaScript 本质上还是解释型语言，还迎合 Web 有一大特色：编译和压缩…</p>
<ul>
<li>编译完了之后 Class Name 可能叫做 <code>User_1</code></li>
<li>压缩完了之后参数 <code>myName</code> 可能叫 <code>m</code></li>
<li>运行时可能传了 2 个，3  个，或者 N 个参数</li>
</ul>
<p><code>angular 1.x</code> 中使用的依赖注入，采用传字符串那么蹩脚的方式，也是对 JavaScript 反射机制的不完善做出的一种妥协。</p>
<p>在下一篇《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233051.html">从 JavaScript 到 TypeScript 5 - express 路由进化</a>》 中，我们将在 express 上，使用装饰器和反射实现全新的路由表现。</p>
<p>&nbsp;</p>
<p>TypeScript 中文网：<a target="_blank" rel="noopener" href="https://tslang.cn/">https://tslang.cn/</a> </p>
<p>TypeScript 视频教程：《<a target="_blank" rel="noopener" href="https://nodelover.me/course/ts-basic">TypeScript 精通指南</a>》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/e6877d92/" data-id="cloizszv3001jxww6bzle0y2b" data-title="从 JavaScript 到 TypeScript 4 - 装饰器和反射" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/从JavaScript到TypeScript5-路由进化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/142b503f/" class="article-date">
  <time class="dt-published" datetime="2017-10-11T15:30:00.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/142b503f/">从 JavaScript 到 TypeScript 5 - 路由进化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>随着应用的庞大，项目中 JavaScript 的代码也会越来越臃肿，这时候许多 JavaScript 的语言弊端就会愈发明显，而 TypeScript 的出现，就是着力于解决 JavaScript 语言天生的弱势：静态类型。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<p>这篇文章首发于我的个人博客 《<a target="_blank" rel="noopener" href="http://tasaid.com/">听说</a>》，系列目录：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011231943.html">从 JavaScript 到 TypeScript 1 - 什么是 TypeScript</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232755.html">从 JavaScript 到 TypeScript 2 - 基础特性和类型推导</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232938.html">从 JavaScript 到 TypeScript 3 - 引入和编译</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233014.html">从 JavaScript 到 TypeScript 4 - 装饰器和反射</a>》</li>
<li>《从 JavaScript 到 TypeScript 5 - express 路由进化》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233132.html">从 JavaScript 到 TypeScript 6 - vue 引入 TypeScript</a>》</li>
</ul>
<p>在上一篇文章 《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233014.html">从 JavaScript 到 TypeScript 4 - 装饰器和反射</a>》 我们介绍了装饰器和反射，在这篇文章中，我们会把这两个特性引入，并且在 <a target="_blank" rel="noopener" href="http://www.expressjs.com.cn/">express</a> 上，实现一层全新的路由封装。</p>
<h2 id="express-路由"><a href="#express-路由" class="headerlink" title="express 路由"></a>express 路由</h2><p>首先我们来看一个简单的 <code>express</code> 路由 (router):</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对网站首页的访问返回 &quot;Hello World!&quot;</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req: Request, res: Response</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="keyword">function</span> (<span class="params">req: Request, res: Response</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">`User Id <span class="subst">$&#123;req.query.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上面的路由代码我们演示了一个普通流水线式的路由。</p>
<p>基于上一篇文章中我们学到的装饰器和反射的知识，我们将要实现 <strong>路由的配置通过装饰器实现</strong>，并且实现一层路由逻辑的封装。</p>
<h2 id="路由进化"><a href="#路由进化" class="headerlink" title="路由进化"></a>路由进化</h2><p>基于装饰器和反射，我们要实现的路由最终效果是这样的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">  <span class="meta">@path</span>(<span class="string">&#x27;/user&#x27;</span>)</span><br><span class="line">  <span class="meta">@httpGet</span></span><br><span class="line">  user (<span class="attr">id</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`User Id <span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET  HTTP/1.1</span><br><span class="line">Host: /user?<span class="built_in">id</span>=tasaid.com</span><br></pre></td></tr></table></figure>

<p>这段代码相比传统的路由配置，优点如下：</p>
<ul>
<li>将路由的配置抽离成为了装饰器，让整个 <code>router</code> 函数内部只需要处理业务逻辑即可，路由配置简单明了</li>
<li>隐藏 <code>req</code> 和 <code>res</code>，每个 <code>router</code> 直接返回结果即可，无需自己再输出结果</li>
</ul>
<h3 id="装饰器-HTTP-Method"><a href="#装饰器-HTTP-Method" class="headerlink" title="装饰器: HTTP Method"></a>装饰器: HTTP Method</h3><p>我们先编写 <code>HTTP Method</code> 的装饰器，我们将实现两个装饰器，分别叫做 <code>httpGet</code> 和 <code>httpPost</code>，对应 HTTP Method 的 <code>GET/POST</code>。</p>
<p>原理上，我们会将 <code>router</code> 配置的数据都挂到使用装饰器的方法上。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> symbolHttpMethodsKey = <span class="title class_">Symbol</span>(<span class="string">&quot;router:httpMethod&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> httpGet = <span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 挂载到调用装饰器的方法上</span></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(symbolHttpMethodsKey, <span class="string">&#x27;get&#x27;</span>, target, propertyKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> httpPost = <span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(symbolHttpMethodsKey, <span class="string">&#x27;post&#x27;</span>, target, propertyKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装饰器-path"><a href="#装饰器-path" class="headerlink" title="装饰器: path"></a>装饰器: path</h3><p>有了上面  <code>HTTP Method</code> 装饰器的实现，我们再实现 <code>path</code> 装饰器将会很简单。</p>
<p>当然，我们还可以在 <code>path</code> 中实现对原方法的封装：隐藏 <code>req</code> 和 <code>res</code>，并对 router 的输出结果进行封装。</p>
<p>注意这里使用的是装饰器工厂：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> symbolPathKey = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;router:path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> path = (<span class="attr">path</span>: <span class="built_in">string</span>): <span class="function"><span class="params">Function</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: TypedPropertyDescriptor&lt;<span class="built_in">Function</span>&gt;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(symbolPathKey, path, target, propertyKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!descriptor.<span class="property">value</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 覆盖掉原来的 router method，在外层做封装</span></span><br><span class="line">    <span class="keyword">let</span> oldMethod = descriptor.<span class="property">value</span></span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params">req: Request, res: Response</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> params = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, req.<span class="property">body</span>, req.<span class="property">query</span>)</span><br><span class="line">      <span class="keyword">let</span> methodResult = oldMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>, params)</span><br><span class="line">      <span class="comment">// 输出返回结果</span></span><br><span class="line">      res.<span class="title function_">send</span>(methodResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Router-Controller"><a href="#Router-Controller" class="headerlink" title="Router? Controller!"></a>Router? Controller!</h3><p>现在，我们需要将所有的 Router 按照自己的业务规则&#x2F;或者自定义的其他规则进行归类 —— 然后提取出对应的 <code>Class</code>，例如下面的 <code>User Class</code> 就是把用户信息所有的 <code>router</code> 都归类在一起：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="meta">@httpPost</span></span><br><span class="line">  <span class="meta">@path</span>(<span class="string">&#x27;/user/login&#x27;</span>)</span><br><span class="line">  <span class="title function_">login</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@httpGet</span></span><br><span class="line">  <span class="meta">@path</span>(<span class="string">&#x27;/user/exit&#x27;</span>)</span><br><span class="line">  <span class="title function_">exit</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>express</code> 配置的入口逻辑那里，把 <code>class</code> 对应的方法遍历一遍，然后使用 <code>reflect-metadata</code> 反射对应的 <code>router</code> 配置即可：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"><span class="comment">// 装饰器挂载数据的 key</span></span><br><span class="line"><span class="keyword">import</span> &#123; symbolHttpMethodsKey, symbolPathKey &#125; <span class="keyword">from</span> <span class="string">&#x27;./decorators&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createController</span> = (<span class="params">app: Express</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> methodName <span class="keyword">in</span> user) &#123;</span><br><span class="line">    <span class="keyword">let</span> method = user[methodName]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> method !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 反射得到挂载的数据</span></span><br><span class="line">    <span class="keyword">let</span> httpMethod = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(symbolHttpMethodsKey, user, methodName)</span><br><span class="line">    <span class="keyword">let</span> path = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(symbolPathKey, user, methodName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// app.get(&#x27;/&#x27;, () =&gt; any)</span></span><br><span class="line">    app[httpMethod](path, method)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的 <code>express</code> 路由进化完毕，效果如下：</p>
<p><img src="//static.tasaid.com/blogs/1e9c56855d825cd3c6e22af5553f4840.png" alt="路由进化"></p>
<p>完整的例子可以参考我的 <a target="_blank" rel="noopener" href="https://github.com/linkFly6/ts-router-to-controller">Github</a>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>装饰器目前在 ECMAScript 新提案中的 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-decorators">建议征集的第二阶段(Stage 2)</a>，由于装饰器在其他语言中早已实现，例如 Java 的注解(Annotation) 和 C# 的特性(Attribute)，所以纳入 ECMAScript 规范只是时间问题了。</p>
<p>装饰器来装饰路由，并且封装 <code>router</code> 操作的的思路缘起 <code>.NET MVC</code> 架构：</p>
<p><img src="//static.tasaid.com/blogs/3a2e5a58317f1e155f34684febcd921f.png" alt=".NET MVC"></p>
<p><code>angular 2.x</code> 使用也引入了装饰器作为核心开发，随着规范的推进，相信装饰器进入大家视野，应用的场景也会越来越多。</p>
<p>在下一篇文章 《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233132.html">从 JavaScript 到 TypeScript 6 - Vue 引入 TypeScript</a>》 中，我们将介绍如何在 Vue 中引入 TypeScript。</p>
<p>&nbsp;</p>
<p>TypeScript 中文网：<a target="_blank" rel="noopener" href="https://tslang.cn/">https://tslang.cn/</a> </p>
<p>TypeScript 视频教程：《<a target="_blank" rel="noopener" href="https://nodelover.me/course/ts-basic">TypeScript 精通指南</a>》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/142b503f/" data-id="cloizszv3001mxww6ciyk8xf5" data-title="从 JavaScript 到 TypeScript 5 - 路由进化" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/从JavaScript到TypeScript3-引入和编译" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/9699a7a8/" class="article-date">
  <time class="dt-published" datetime="2017-10-11T15:29:00.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/9699a7a8/">从 JavaScript 到 TypeScript 3 - 引入和编译</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>随着应用的庞大，项目中 JavaScript 的代码也会越来越臃肿，这时候许多 JavaScript 的语言弊端就会愈发明显，而 TypeScript 的出现，就是着力于解决 JavaScript 语言天生的弱势：静态类型。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<p>这篇文章首发于我的个人博客 《<a target="_blank" rel="noopener" href="http://tasaid.com/">听说</a>》，系列目录：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011231943.html">从 JavaScript 到 TypeScript 1 - 什么是 TypeScript</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232755.html">从 JavaScript 到 TypeScript 2 - 基础特性和类型推导</a>》</li>
<li>《从 JavaScript 到 TypeScript 3 - 引入和编译》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233014.html">从 JavaScript 到 TypeScript 4 - 装饰器和反射</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233051.html">从 JavaScript 到 TypeScript 5 - express 路由进化</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233132.html">从 JavaScript 到 TypeScript 6 - vue 引入 TypeScript</a>》</li>
</ul>
<p>在上一篇文章 《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232755.html">从 JavaScript 到 TypeScript 2 - 基础特性和类型推导</a>》 中我们讨论了一些基本的 TypeScript 类型特性。许多人摩拳擦掌跃跃欲试，这篇文章我们主要介绍如何引入和编译 TypeScript。</p>
<h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i -g typescript</span></span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tsc helloworld.ts</span></span><br></pre></td></tr></table></figure>

<p>如果我们想快速测试一个文件，可以使用 <a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">ts-node</a>，<code>ts-node</code> 可以让我们通过命令直接执行 <code>*.ts</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i -g ts-node</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行当前文件夹下 demo.ts 文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ts-node demo.ts</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出的执行结果</span></span><br></pre></td></tr></table></figure>

<p>关于 <code>tsc</code>，一般来说，全局安装的方案并不是很棒，我们可以把 typescript 安装到本地项目目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i  --save-dev typescript</span></span><br></pre></td></tr></table></figure>

<p>这样在 <code>package.json</code> 的 <code>scripts</code> 中可以引用 <code>tsc</code> 命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.4.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>npm run build</code> 命令即可启用 <code>tsc</code> 命令编译本地目录，<code>typescript</code> 会去查找目录下的 <code>tsconfig.json</code> 配置文件。</p>
<p>引入 TypeScript 非常简单，TypeScript 的文件后缀为 <code>ts</code>，迁移 TypeScript 只需要将项目中，业务代码的 <code>*.js</code> 修改为 <code>*.ts</code> 即可。不过在此之后你会看到大量的报错，然后就是按照 TypeScript 的规则，解决这些报错即可:)</p>
<p><img src="//static.tasaid.com/blogs/e1c340f248b8dad18c05d28c7a462680.png" alt="引入和编译-类型报错"></p>
<h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p><code>tsconfig.json</code> 是 TypeScript 的编译选项文件，通过配置它来定制 TypeScript 的编译细节。</p>
<ul>
<li>直接调用 <code>tsc</code>，编译器会从当前目录开始去查找 <code>tsconfig.json</code> 文件，逐级向上搜索父目录。</li>
<li>调用 <code>tsc -p</code>，可以指定一个包含 <code>tsconfig.json</code>文件的目录进行编译。如果没有找到 <code>tsconfig.json</code> 文件，<code>TypeScript</code> 会编译每个文件并在对应文件的同级目录产出。</li>
</ul>
<blockquote>
<p>如果你要编译的是一个 Node 项目，请先安装 Node 编译依赖： <code>npm i @types/node --save-dev</code>，否则会出现 Node 内置模块无法找到的情况。</p>
</blockquote>
<p>一个 <code>tsconfig.json</code> 文件描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 编译选项</span></span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出目录</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./output&quot;</span>,</span><br><span class="line">    <span class="comment">// 是否包含可以用于 debug 的 sourceMap</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 以严格模式解析</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 采用的模块系统</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="comment">// 如何处理模块</span></span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="comment">// 编译输出目标 ES 版本</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">    <span class="comment">// 允许从没有设置默认导出的模块中默认导入</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 将每个文件作为单独的模块</span></span><br><span class="line">    <span class="string">&quot;isolatedModules&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 启用设计类型元数据（用于反射）</span></span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 在表达式和声明上有隐含的any类型时报错</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不是函数的所有返回路径都有返回值时报错。</span></span><br><span class="line">    <span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 从 tslib 导入外部帮助库: 比如__extends，__rest等</span></span><br><span class="line">    <span class="string">&quot;importHelpers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 编译过程中打印文件名</span></span><br><span class="line">    <span class="string">&quot;listFiles&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 移除注释</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;suppressImplicitAnyIndexErrors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 允许编译javascript文件</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定特殊模块的路径</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;jquery&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// typescript 语法检测支持的版本库，注意不是 polyfill！只是为了有对应版本的代码特性提示！</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">      <span class="string">&quot;es2015.promise&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整 <code>tsconfig</code> 配置选项的可以参考 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">这里</a>，或者 tsconfig 的 <a target="_blank" rel="noopener" href="http://json.schemastore.org/tsconfig">json-schema</a>。</p>
<p>注意： TypeScript 不会做 <code>Polyfill</code>，例如从 <code>es6</code> 编译到 <code>es5</code>，TypeScript 编译后不会处理 <code>es6</code> 的那些新增的对象的方法，如果需要 <code>polyfill</code> 需要自行处理！</p>
<p>完整的编译选项请参阅 <a target="_blank" rel="noopener" href="https://tslang.cn/docs/handbook/compiler-options.html">TypeScript 中文网</a> 和 <a target="_blank" rel="noopener" href="http://www.typescriptlang.org/docs/handbook/compiler-options.html">TypeScript 官网</a>。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>大多数前端已经使用各种各样的构建工具，完整构建工具集成列表参见 <a target="_blank" rel="noopener" href="https://tslang.cn/docs/handbook/integrating-with-build-tools.html">这里</a></p>
<p>对于 Node 项目，建议搭配 <code>gulp</code> 使用。不过个人更喜欢通过 <code>npm scripts</code> 脚本组合命令，然后直接使用 <code>tsc</code> 编译，例如我自己的编译方案。</p>
<p>项目目录为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---output <span class="comment"># 编译输出</span></span><br><span class="line">|---client</span><br><span class="line">|---server <span class="comment"># node ts 文件目录</span></span><br><span class="line">      |--tsconfig.json</span><br><span class="line">|---package.json</span><br></pre></td></tr></table></figure>

<p><code>package.json</code> 中 <code>scripts</code> 脚本如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nodemon --ext ts --watch server --exec \&quot;npm run clean &amp;&amp; npm run build:ts &amp;&amp; npm run server\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=development node ./output/app.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rm -rf ./output.server&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build:ts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc -p ./server&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run clean &amp;&amp; npm run build:ts&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>nodemon</code> 监听整个 <code>server</code> 目录文件改动并执行脚本</li>
<li><code>npm run clean</code> 用于清空编译输出目录</li>
<li><code>npm run build:ts</code> 用于编译 <code>server</code> 目录下的 TypeScript 文件</li>
<li><code>npm run server</code> 用于启动编译后的 node 服务器。</li>
</ul>
<p>平常开发只需要 <code>npm run dev</code>，生产使用 <code>npm run build</code> 产出文件即可。</p>
<h2 id="visual-studio-code-集成和-debug"><a href="#visual-studio-code-集成和-debug" class="headerlink" title="visual studio code 集成和 debug"></a>visual studio code 集成和 debug</h2><h3 id="编译任务"><a href="#编译任务" class="headerlink" title="编译任务"></a>编译任务</h3><p><code>visual studio code</code> 编译 <code>TypeScript</code> 非常简单，根据上面我自己的组合命令，只需要在 <code>vs code</code> 的任务中加入编译脚本即可（<code>npm run build-ts</code>）：</p>
<p><code>./.vscode/task.json</code> 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// npm 命令</span></span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line">      <span class="comment">// npm run 的脚本</span></span><br><span class="line">      <span class="string">&quot;script&quot;</span>: <span class="string">&quot;build-ts&quot;</span>,</span><br><span class="line">      <span class="comment">// 标签</span></span><br><span class="line">      <span class="string">&quot;label&quot;</span>: <span class="string">&quot;build-typescript&quot;</span>,</span><br><span class="line">      <span class="comment">// 默认任务</span></span><br><span class="line">      <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">        <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按 <code>control+shift+B</code> 即可编译。</p>
<p><img src="//static.tasaid.com/blogs/ca484d61d09a03e92c816b2539c39767.jpeg" alt="编译 Code"></p>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>在 <code>./.vscode/launch.json</code> 中加入如下代码即可调试，记得要在 <code>tsconfig.json</code> 里打开 <code>sourceMap</code> 选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 调试前运行的任务 (task)，就是上面编译任务中的 label</span></span><br><span class="line">      <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build-typescript&quot;</span>,</span><br><span class="line">      <span class="comment">// 调试任务名称</span></span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;server debug&quot;</span>,</span><br><span class="line">      <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 传递的参数</span></span><br><span class="line">        <span class="string">&quot;NODE_ENV&quot;</span>: <span class="string">&quot;development&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 调试的 node 入口文件，注意 tsconfig.json 里面要打开 sourceMap</span></span><br><span class="line">      <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/output/app.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>vs code</code> 中给代码打上断点，按 F5，一步步调试即可。</p>
<p><img src="//static.tasaid.com/blogs/b3aaefb3dcfacd5a6efd35abd0d5a50a.gif" alt="vscode debug"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们简单总结一下：</p>
<ul>
<li>使用 <code>ts-node</code> 可以让我们直接运行 <code>*.ts</code> 文件（不过只建议临时运行代码或特殊应用场景使用）</li>
<li>使用 <code>typescript</code> 产出的 <code>tsc</code> 命令来编译 <code>*.ts</code> 文件到 <code>*.js</code>，然后我们运行编译出来的 <code>*.js</code> 文件即可</li>
<li>使用 <code>tsconfig.json</code> 配置 TypeScript 的编译选项</li>
</ul>
<p>在下一篇，我们将了解逐渐盛行的 ECMAScript 特性在 TypeScript 上的应用：《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233014.html">从 JavaScript 到 TypeScript 4 - 装饰器和反射</a>》</p>
<p>&nbsp;</p>
<p>TypeScript 中文网：<a target="_blank" rel="noopener" href="https://tslang.cn/">https://tslang.cn/</a> </p>
<p>TypeScript 视频教程：《<a target="_blank" rel="noopener" href="https://nodelover.me/course/ts-basic">TypeScript 精通指南</a>》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/9699a7a8/" data-id="cloizszv2001cxww6a3948ouf" data-title="从 JavaScript 到 TypeScript 3 - 引入和编译" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/从JavaScript到TypeScript2-基础特性和类型推导" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/29102f33/" class="article-date">
  <time class="dt-published" datetime="2017-10-11T15:27:00.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/29102f33/">从 JavaScript 到 TypeScript 2 - 基础特性和类型推导</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>随着应用的庞大，项目中 JavaScript 的代码也会越来越臃肿，这时候许多 JavaScript 的语言弊端就会愈发明显，而 TypeScript 的出现，就是着力于解决 JavaScript 语言天生的弱势：静态类型。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<p>这篇文章首发于我的个人博客 《<a target="_blank" rel="noopener" href="http://tasaid.com/">听说</a>》，系列目录：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011231943.html">从 JavaScript 到 TypeScript 1 - 什么是 TypeScript</a>》</li>
<li>《从 JavaScript 到 TypeScript 2 - 基础特性和类型推导》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232938.html">从 JavaScript 到 TypeScript 3 - 引入和编译</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233014.html">从 JavaScript 到 TypeScript 4 - 装饰器和反射</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233051.html">从 JavaScript 到 TypeScript 5 - express 路由进化</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011233132.html">从 JavaScript 到 TypeScript 6 - vue 引入 TypeScript</a>》</li>
</ul>
<p>在上一篇文章 《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011231943.html">从 JavaScript 到 TypeScript 1 - 什么是 TypeScript</a>》 中我们讨论了什么是 TypeScript。这一篇文章我们来介绍 TypeScript 一些基础类型约束。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>我们先简单的声明一些变量：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>  <span class="comment">// 有默认值的情况，甚至不需要声明类型，ts 会自动推导</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] <span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125; <span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;linkFly&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当我们给这些变量赋错误的类型值的时候，会抛出类型错误异常。</p>
<p><img src="//static.tasaid.com/blogs/47d85e4a5d954994c4cac8d15682d127.png" alt="错误提示"></p>
<p>是不是很简单，TypeScript 优秀的设计使得即使你没有接触过它，但是仍然能够读懂它。</p>
<h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list_a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">list_b</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// number 类型的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list_c</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;linkFly&#x27;</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// any</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="literal">true</span> <span class="comment">// any 类型可以自由赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fn</span>: <span class="function">(<span class="params">id: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">id</span>) =&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 这里使用了 ECMAScript 6 的箭头函数，和下面的代码等价</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fn</span>: <span class="function">(<span class="params">id: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/82b705a6a6154a2aedfb66bb6a3b8f84.png" alt="类型推导"></p>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型, foo 是 string 或 number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型断言，强制使用兼容类型中的某一类型</span></span><br><span class="line">(foo <span class="keyword">as</span> <span class="built_in">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型保护(判断)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型保护(判断)</span></span><br><span class="line"><span class="keyword">if</span> (foo <span class="keyword">instanceof</span> <span class="title class_">String</span>) &#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/205cbccb401525d6016ec0cf0eaa31f1.jpeg" alt="类型保护"></p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>从前几年热门的 <code>MVC</code> 一直到现在热门的 <code>MVVM</code>，我们发现无论是 MVC(Model-View-Controller)  还是 MVVM(Model-View-ViewModel)，我们始终抛不开一个关键的地方 —— 数据层：<code>Model</code>。</p>
<p>因为本质上整个页面的操作都是在进行数据流动，页面展现本质上都是数据，而我们通过 <code>Model</code> 来描述数据。</p>
<p>这是一个简单的 <code>Model</code> 演示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user : &#123; <span class="attr">id</span>: <span class="built_in">number</span>, <span class="attr">name</span>: <span class="built_in">string</span> &#125; = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;linkFly&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在 TypeScript （或者是所有强 OO 语言）中，推荐以 <code>Model</code> 来描述数据的方式也就是 <code>Class</code>。</p>
<p>这一小节只简单介绍 Class 和 泛型，实际项目中可能还会牵扯更多更强大的 OO 概念：接口、抽象类、继承类、继承属性。</p>
<p>这些知识不是一蹴而就的，而是需要在项目中不断探索不断组合的。</p>
<h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><p>所有类型的根本都是类，TS 中声明一个类的语法非常简单，可读性很高。</p>
<p>注意，TS 中类型是核心，当你想把一个项目从 JavaScript 迁移到 TypeScript 的时候，需要为项目中补充大量的类型，而这些类型大部分都是基于 <code>Class</code> 构建的。</p>
<p>这是一个简单的类：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;linkFly&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当然随着需求的不同，也可以补充很多细节：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">// 只读属性</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存取器, get/set</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="comment">// dosomething </span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">  set name (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set method&#x27;</span>)</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">id</span>: <span class="built_in">number</span>, <span class="attr">theName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">      <span class="comment">// 只读属性只能在构造函数里初始化</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_name</span> = theName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`name: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法（类方法）</span></span><br><span class="line">  <span class="keyword">static</span> print () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;static method&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&#x27;linkFly&#x27;</span>)</span><br><span class="line">user.<span class="property">name</span> = <span class="string">&#x27;tasaid&#x27;</span> <span class="comment">// 会输出 &#x27;this is set method&#x27;</span></span><br><span class="line">user.<span class="title function_">say</span>() <span class="comment">// 实例方法</span></span><br><span class="line"><span class="title class_">User</span>.<span class="title function_">print</span>() <span class="comment">// 静态方法</span></span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/60f27dab245dc4d56c84b445aef2087f.png" alt="Model_User"></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是用来解决类型重用的问题。</p>
<p>例如下面一个函数，只能传递 <code>number</code> 的参数并返回：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在想传递一个 <code>string</code> 类型的参数，然后也返回它，这个时候就可以使用泛型，使用泛型可以接收任意类型并返回：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 T 就是泛型，也可以叫其他名字</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;linkfly&#x27;</span>)</span><br><span class="line"><span class="title function_">identity</span>(<span class="string">&#x27;linkfly&#x27;</span>) <span class="comment">// 自动推导</span></span><br><span class="line"><span class="title function_">identity</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">identity</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>


<p>我们可以轻松的使用泛型来实现数据包装：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fetch&lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 远程请求数据并返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">http</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data <span class="keyword">as</span> T</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型使用</span></span><br><span class="line"><span class="keyword">let</span> user = fetch&lt;<span class="title class_">User</span>&gt;(<span class="string">&#x27;https://tasaid.com/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="小-tips"><a href="#小-tips" class="headerlink" title="小 tips"></a>小 tips</h2><ul>
<li><a target="_blank" rel="noopener" href="https://tslang.cn/docs/handbook/decorators.html">TypeScript 中文网</a> 可以看到完整 TS 类型。</li>
<li>在项目初期使用 TS 中，会需要很大的时间和精力，去编写和架构基本业务类型(Models)，在此之后会越来越方便快捷。</li>
<li>一些没有行为只需要做类型检查的类型（没有方法的 Models），可以使用 <a target="_blank" rel="noopener" href="https://tslang.cn/docs/handbook/declaration-files/introduction.html">TypeScript 声明文件 （*.d.ts）</a>，例如：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">Models</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> GPS &#123;</span><br><span class="line">    <span class="attr">lat</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">lng</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个系列的文章不会讲解 TypeScript 的声明文件，但是它是 TypeScript 中不可缺少的一部分。</p>
<ul>
<li>尽量减少使用 <code>any</code> 类型，它意味着类型不可控</li>
<li>某些变量或者第三方库中属性无法感知，使用 <code>as</code> 强制进行类型推导即可。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">tempName</span> = <span class="string">&#x27;linkFly&#x27;</span> </span><br><span class="line"><span class="comment">// Errors: [ts] Property &#x27;tempName&#x27; does not exist on type &#x27;Window&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制推导</span></span><br><span class="line">(<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">tempName</span> = <span class="string">&#x27;linkFly&#x27;</span></span><br></pre></td></tr></table></figure>

<p>至此，我们对 TypeScript 类型、Model 已经有了一定的了解，在下一篇，我们将了解如何引入和编译 TypeScript：《<a target="_blank" rel="noopener" href="http://tasaid.com/Blog/20171011232938.html">从 JavaScript 到 TypeScript 3 - 引入和编译</a>》</p>
<p> &nbsp;</p>
<p>TypeScript 中文网：<a target="_blank" rel="noopener" href="https://tslang.cn/">https://tslang.cn/</a> </p>
<p>TypeScript 视频教程：《<a target="_blank" rel="noopener" href="https://nodelover.me/course/ts-basic">TypeScript 精通指南</a>》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/29102f33/" data-id="cloizszv10019xww693fz1s35" data-title="从 JavaScript 到 TypeScript 2 - 基础特性和类型推导" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/article/">article</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tech/">tech</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Said/" rel="tag">Said</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTTPS/" style="font-size: 12.5px;">HTTPS</a> <a href="/tags/JavaScript/" style="font-size: 17.5px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Said/" style="font-size: 15px;">Said</a> <a href="/tags/TypeScript/" style="font-size: 20px;">TypeScript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/cfe1281/">一段职业生涯的总结</a>
          </li>
        
          <li>
            <a href="/posts/8127ee4b/">一段旅程</a>
          </li>
        
          <li>
            <a href="/posts/29a0bec0/">折旧</a>
          </li>
        
          <li>
            <a href="/posts/75b36508/">一无所知</a>
          </li>
        
          <li>
            <a href="/posts/688d139e/">TypeScript 中的多种 import 解义</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>