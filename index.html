<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>听说 - 世界很大，风住过这里</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="听说 - 世界很大，风住过这里">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="听说 - 世界很大，风住过这里">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="听说 - 世界很大，风住过这里" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">听说 - 世界很大，风住过这里</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-blogs/一段职业生涯的总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/cfe1281/" class="article-date">
  <time class="dt-published" datetime="2021-10-13T14:55:00.000Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/cfe1281/">一段职业生涯的总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>近期要从工作了 5 年的公司离开，进入到自己的下一份工作经历。</p>
<p>这 5 年的工作经历中自己发生了许许多多的改变，最为欣慰的无论于内心，还是客观结果上，这 5 年来收获满满，自觉无愧于心。</p>
<p>千言万语，这一篇作为我这一段职业生涯的反思吧，在一些小的领域上有了新的认知以及变化，有些是我主动去学习和观察所得，有些是本身的环境和自身变化被动去摸索。</p>
<h2 id="对于技术保持既有的尊重，同时更多的去学习非技术的专业领域。"><a href="#对于技术保持既有的尊重，同时更多的去学习非技术的专业领域。" class="headerlink" title="对于技术保持既有的尊重，同时更多的去学习非技术的专业领域。"></a>对于技术保持既有的尊重，同时更多的去学习非技术的专业领域。</h2><p>互联网的技术身份让我时刻保持着对于技术的追求，我所认知的工作内容就是：我们都一直在发现问题，定义问题和解决问题。所谓的成长指的是我们如何发现更大的问题，定义更大的问题，以及解决更大的问题。</p>
<p>初级工程师解决具象化的功能问题，高级工程师解决具象化的项目问题，架构师解决抽象化的领域问题。技术经理解决抽象的协同效率问题。</p>
<p>成长就是是指你能从解决具象问题，到抽象问题的过程。</p>
<p>问题也是有大有小的，多个问题组合起来就会变成抽象问题，因为千丝万缕的联系，以及众多变量在持续变化，会让问题变得难以看清。例如典型的 “组织问题” 就是一个包含制度，资源，事项，甚至个体与个体关系都会引发的抽象的问题。</p>
<p>所以抽象问题不是技术本身可以去解决的，你需要拥有更多解决问题的工具。技术只是其中之一。这也就是我们常说的 “技术是解决问题的工具之一”。</p>
<p>大多数人做技术是因为热爱，所以会陷入“技术自留地”，享受过去经验解决问题的快感。而忽略了技术的工具属性，没有强化学习自己的其他技能。</p>
<p>实际上，从职业生涯的每个阶段我们都必须保持自己全面发展综合技能，除了技术，我们应该还需关注：技术嗅觉，定义问题，沟通表达，提炼总结，资源协同，以及管理自己这些能力。</p>
<p>在国内的大环境下，技术性工种的天花板大部分都不是技术本身，而是个人的综合能力。</p>
<h2 id="对于社会经验上，要学会如何从社会视角中观察自己。"><a href="#对于社会经验上，要学会如何从社会视角中观察自己。" class="headerlink" title="对于社会经验上，要学会如何从社会视角中观察自己。"></a>对于社会经验上，要学会如何从社会视角中观察自己。</h2><p>我们常会忽略自己的社会经验，但实际上我们身处社会之中。当然，我们也可以抗拒学习社会经验，社会自然会吊打你。</p>
<p>常见的社会经验就是处事的成熟度，例如是否是否敢于承担责任，是否融洽于职场的千百态之中。这里提供一条检验方式，你在职场中的朋友和敌人各有多少？“把朋友搞的多多的，把敌人搞的少少的”。</p>
<p>多数人会觉得这样太圆滑了，不符合自己的三观。那是因为你只想到了圆滑的方式去解决这个问题。</p>
<p>实际上，尊重每个个体，公平客观的待人大多数时候也可以让你把朋友搞的多多的，敌人搞的少少的。</p>
<p>当然社会经验肯定不限于 “处朋友” 这样的社交场景，但处朋友一定能有效帮助你提升社会经验。</p>
<p>更主要的是，我们要学会如果从社会视角中观察自己。这个社会视角是指主要观察自身的社会属性，大多数和情商相关：心智，经验，观察力，表达，以及克制。</p>
<p>其中 “克制自己” 值得拿出来说一说。我们看待任何一件事情都是源于心里最真实的那个自己，而我们学习的过程中一定会让内心最本源的自己非常痛苦。这个时候克制自己就是非常重要的技能了 —— 你是否可以战胜过去的自己？</p>
<h2 id="要学会始终以组织视角看待团队。"><a href="#要学会始终以组织视角看待团队。" class="headerlink" title="要学会始终以组织视角看待团队。"></a>要学会始终以组织视角看待团队。</h2><p>从业开始，我始终强调自己的认知：以团队视角做事。这个认知让我受益匪浅。</p>
<p>回顾这 5 年，许多的事情都是基于这个认知而做的，这也是让我个人完成角色转变，变成团队负责人的关键点。这份工作经历中角色的许多拐点都有这个认知在做支撑，从带领几个人，到带领两条业务线的 30 人团队。</p>
<p>因为我总是强迫自己去使用更高一维的视角去训练自己。</p>
<p>当我是个体的时候，我看团队收益。当我带某一个团队的时候，我看组织收益。</p>
<p>正是这个视角，让许多团队的管理动作，团队问题都会变得十分清晰。而不是在当下的环境中无限抱怨。抱怨从来解决不了问题，解决问题的那个人才是主角。</p>
<p>所以时刻使用一个更大的组织视角来观察自己，一方面会让自己可以发现更多的问题，给自己创造解决问题的机会。另一方面是用新的刻度尺来标记自己的位置，从而让自己更具有职场的竞争动力。</p>
<h2 id="对于初心，要愈发的敬重。"><a href="#对于初心，要愈发的敬重。" class="headerlink" title="对于初心，要愈发的敬重。"></a>对于初心，要愈发的敬重。</h2><p>简单来说，我们总是会在心中憧憬一个理想化的未来。但随着年龄的推进，社会经验的富足，身体的变化，会让自己憧憬的理想变得越来越模糊。</p>
<p>但它必须得有，因为我们在成长过程中遇到许多的困难，我们会有无数次的想要放弃，这就是心里的最后一道防线。理想可以模糊，但必须要有。</p>
<p>保持理想化的最好方式是尊重。不去自我抨击从而让它变得消极，也不能过分憧憬从而跌入深渊，而是尊重。</p>
<p>我个人的理想是希望自己创业，而随着工作经验和阅历的增加愈发的觉得这件事情很困难，远远超出了自己当下的认知。</p>
<p>但是我仍然会持续以创业的标准去要求自己的心态。虽然认知到当下有许多不足，但这正是我学习与成长的动力。</p>
<h2 id="对于时间和精力，要学会管理自己。"><a href="#对于时间和精力，要学会管理自己。" class="headerlink" title="对于时间和精力，要学会管理自己。"></a>对于时间和精力，要学会管理自己。</h2><p>这一点是自己做的最烂的，因为发自心底的热爱事业带来的成就感，所以大部分精力和时间都扑在了工作上。</p>
<p>在工作上一定要学会管理自己的时间与精力。例如多少的精力用来学习，多少的经历用来糊口，多少的精力去提升解决问题的能力。这些一定要有自己的节奏。</p>
<p>工作中，我们会被各种临时事项干扰，实际上是这些事情已经不属于你的控制之中。任何时候，需要有自己的精力分配和时间的管理的节奏。</p>
<p>我们工作中的紧急重要的任务其实没有那么多，大多数时候是精力分配不匀导致。把精力用来解决关键问题。控制事情，而不是让事情控制自己。</p>
<p>然而还有个更大的问题实际上我也并没有好好解决掉，就是工作和生活的平衡，这份工作经历中，和家人的沟通越来越少，距离感越来越强，有限的家庭生活中总是怀着补偿的心理。</p>
<p>月有阴晴圆缺，这也是需要自己不断攻克的课题吧。</p>
<p>最后，认清自己是个凡人。也或许是因为自己未到 30 岁，依然保留着年轻人的热血，骨子里仍然憧憬着 “世界为我而造”。正是这份初心，鼓舞着让自己持续追求自我的突破。</p>
<blockquote>
<p>你需要经常在口袋里装上两张纸条,一张上写着‘我只是一粒尘埃’，另一张则写着’世界为我而造’  —— 犹太谚语</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/cfe1281/" data-id="cloj0dpv800312kw6fp8rfaji" data-title="一段职业生涯的总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Said/" rel="tag">Said</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-articles/一段旅程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/8127ee4b/" class="article-date">
  <time class="dt-published" datetime="2021-10-13T14:52:00.000Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/8127ee4b/">一段旅程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>要从工作 5 年的公司离开，10 月 13 日 lastday。即将迎接下一段职业生涯，觉得得留下点什么，洋洋洒洒写了一篇，最后看下来太过理性了，这工作 5 年太多理性的处事风格让自己遗忘了最初感性的部分。</p>
<p>所以又重新写一篇感性的部分，告诉自己没有忘记这些心路历程。</p>
<p>当初进这家公司的时候，是看中了它主营业务的发展前景业务各大创新部门不断萌芽的发展的前景。机缘之下，许多创新的部门早已失去的踪影，而恰好自己无意中选择的这个部门反而在战乱的星火下得以延续。这才有了这 5 年的职业生涯。</p>
<p>或许正是因为这家公司的壮大吧，当年互联网的明日之星，同样吸纳了许多志同道合的人加入进来。这个初创部门小而美，很累很充实，所有的仗一点点打。</p>
<p>所有人背靠背扛枪打仗，嘴上骂着再也不干了，却一次又一次坚持了下来。打了两年到 18 年，我们仍然还在创业一般的氛围中，许多人开始怀疑这一切是为了什么。</p>
<p>一度我也陷入了这种怀疑之中，质疑周边的一切，质疑组织，质疑业务。不断的有人离开让自己更加的质疑。</p>
<p>随着组织人才的流失，团队发生了许多的改变，而恰好我也面临的家庭的巨变，心态跌落到了极致。当时只想打完最后一场仗就跑路，也许自己当时是最佳人选，收到了许多外界的鼓舞，更多是来自新上任上级的鼓舞。</p>
<p>鼓舞的力量真的很大，最终我们打赢了这场仗，迎来了新的机遇，成为了团队的 “临时” 负责人。为什么是临时呢，因为我们都需要去证明自己是合格的。</p>
<p>这样新的机遇和挑战激发了自己内心的使命感，驱动着自己去做的更好，每天提醒自己要对每一个人用心负责。在学习成为团队负责人的时候，要接受许多和自己想的不一样的事情发生，在这个过程中，自己学习到最大的地方就是 “克制自己”。</p>
<p>以此为起点，在成为管理者的路上，愈发的孤独。</p>
<p>当我们是个体的时候，可以自由的成为自我，产生的结果无非是外界的评价而已，无关责任。而当我们成为一个团队的负责人的时候，“负责” 二字也意味着肩膀上的重担，对人，对事，对结果都需负责。</p>
<p>正意味着要对组织，对整体负责，所以视角逐渐的要变成团队视角，甚至更大的组织视角。</p>
<p>当你成为团队负责人，你注定留给团队成员的是背影，因为你永远面朝前方，带领团队前行。所以曾经能在一起无话不谈的兄弟朋友，因为你的转变，因为你的权利，会逐渐有隔阂。</p>
<p>你的决策逻辑是团队的最优解，而团队成员的决策逻辑是他们心中的个人最优解，口中的团队最优解，且无需负责的。</p>
<p>例如淘汰一个人，你的目标永远是在剩余阶段如何挖掘这个人的最大潜力，给予最大包容空间让其证明自己的价值。而团队成员会认为你要求他们严格，对一个不符合团队标准的人却拥有极大的容忍度。你可以去解释，但会带来更多的解释成本。</p>
<p>例如绩效和调整薪资，你会在背后去努力帮助争取那 1%，但有限的资源下仍然少的可怜，从团队中得到的结果反馈上必然带来许多新的负向心理。</p>
<p>例如团队加班很累，你希望可以找个机会让团队放松，但是业务的压力又源源不断。但是你的责任就是支撑住这份业务压力，因为从管理层来看，这就是你的价值。这种选择题的唯一选项就是 “务必支撑好业务”。因为一旦你当下内心任由内心的泛滥，选择了放松团队引发了业务出问题，那么管理层就会质疑你的价值。</p>
<p>一旦团队质疑你的价值，就意味着团队的保护伞已经被摇摆 —— 如果你保护不了你的团队，那么你的善良再多，也一无是处。</p>
<p>所以这个问题的解决方案就是 “务必支撑好业务”，这也就意味着你无法让团队放松 —— 这又与你的善良相悖论。</p>
<p>同时你的缺陷会被放大，决策的逻辑会被人找漏洞。程序的世界由 01 填充，而组织问题是抽象问题，抽象问题上，从来不是非黑即白。</p>
<p>这种无论外界的负重，还是内部的不理解，会持续加重这份孤独感。</p>
<p>但是，这些问题我们仍要直面，因为你唯一负责。即使在这种情况下，仍要保持前行。</p>
<p>持续前行，迎来了 20 人的管理范围，又迎来了 30 人的管理范围，按照自己的逻辑构建了领导梯队，然后更加的孤独。</p>
<p>新的领导梯队中会产生新的负责人，他们也会衍生自我意志，某些情况会与你对抗，但是我们也不能去压制这种情况，因为同样的，我们需要给到这些新任管理者相同的空间和包容。更主要的，我们不能抑制他们的创造力。</p>
<p>这份孤独会常伴，你无法让所有人都满意，也不会每个人都会让你满意，要学会和它共处，颇有悲情的英雄主义气质。会有更多的人无法理解你，也会有更多的人从行动上认可你。</p>
<p>再后来，已经意识到这份职业生涯的阶段应该结束了，是时候去启动下一份职业生涯的阶段了。更主要的，我需要直面自己重启的勇气，以及让这些优秀的管理者能更好的站出来。</p>
<p>所以当一切愈发顺利之中，我选择了后退，把舞台交给这些新培养的管理者。这是一个轮回，让更多优秀的同学去体验，让每个人都学会如何与这份孤独感共处。</p>
<p>我总是会怀念最初来到这里的样子，但是我明白它再也回不来了，不是这里变了，而是我变了。</p>
<blockquote>
<p>创作于 2021-10-12 02:13</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/8127ee4b/" data-id="cloj0dpuu00072kw617dn06tr" data-title="一段旅程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-articles/折旧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/29a0bec0/" class="article-date">
  <time class="dt-published" datetime="2020-07-18T18:01:00.000Z" itemprop="datePublished">2020-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/article/">article</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/29a0bec0/">折旧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>2020 年，地球的自转有许多不一样。</p>
<p>疫情的突如其来，风云变幻，大大的世界下，形形色色的人们每天被改变着。疫情的蝴蝶效应下，推演着许多变化。</p>
<p>在疫情间，和家里通过电话、微信视频的形式维系着千里之外的担心与安抚。</p>
<p>印象里爷爷是个权威的人，一方面在同辈中年长，许多以家族为中心的多数情况以爷爷为决策中心；另一方面是为人正直，也继承自上个世纪的同时代背景下衍生的性格。所以家里的长辈们都十分敬重。但是对于孩子们来说，权威等于严肃，尤其对于长期和爷爷奶奶朝夕相处的我来说，和奶奶的交流会多一些，所以心里对爷爷还是觉得有不可跨越的权威存在，交流略少。</p>
<p>某些场景下，年幼的自己太过淘气，惹过爷爷生气，正经来说，这种场景下，爷爷倒没有揍过淘气的我，只是会训斥。而自尊心作祟的自己总是在心里默默责怪爷爷，甚至觉得爷爷疼爱哥哥和弟弟而不疼爱自己。</p>
<p>不过记忆比较深刻的交流是小时候贪吃零食，会和爷爷要零花钱买零食吃，爷爷每个月也是工资上交给奶奶，自己只留一些够用的零花钱，这些零花钱大多都给了小小的我。</p>
<p>男人本身是不善在日常的柴米油盐中表述疼爱的，但总可以在一些细节中透露出长不大的调皮和藏不住的疼爱。</p>
<p>每天中午放学回家就匆匆打开电视，老式的大后背电视机，在炎炎的夏日下会在某个高温的中午炸掉。爷爷会说：“看你每天回家不知道好好学习就只知道看电视，你看电视炸掉了吧”，可是等下午放学的时候再回家，新的电视机就已经替代了旧电视机的位置 —— 等待我再去打开。</p>
<p>在我津津有味看着新电视的时候，也许从来没有注意过爷爷或许正在慈祥的看着幼稚的我。</p>
<p>爷爷是个技能很多的人，教会了我许多事情，虽然我一天天的长大，学会了许多新鲜的事物，从而背叛了曾经学会的许多旧时代的技能。</p>
<p>爷爷会教我如何正确的捏住筷子，如何用秤砣是称重，如何用算盘算数和记账，如何接电线，如何修好一个木制的凳子，教我如何砍一棵树。在清明节前夕，会教我如何折金元宝，去悼念那些我根本记不清关系的灵魂。</p>
<p>当然还有许多是我并没有学会的，比如会架起一个简单的小炉子，放上碳，放上一个勺子，用猪皮和面粉搅合过的蛋液，来烫出我从小就爱吃的鸡蛋饺。远游许多年，会在外面的饭店餐馆外卖中，吃到许多食物，可是每次回家，总觉得最好吃的都在家里，尤其这个蛋饺。</p>
<p>在爷爷奶奶的目光下，我一点点的长大。小小的我，一点点超过他的身高。看着以前听话懂事的孩子，会在父亲的面前叛逆的争吵。他看着家族的变化，看着我的长大。</p>
<p>终于，我也到了那个需要离家远行的年纪，需要独自面对未来的风浪。</p>
<p>一次次道别，总是爷爷奶奶在楼梯口看着我挥手道别，爷爷几乎没有说过什么。也许爷爷是个不擅长道别的人。</p>
<p>后来，爷爷还是决策家族里的许多事情，只是体力渐渐不支。</p>
<p>爷爷喜欢打麻将，因为身边同辈打麻将的人一个一个离开，和爷爷的体力越来越差，许多的日子里，只能在空荡荡的家里，看电视和睡觉。</p>
<p>这个家里，从爷爷奶奶，随着父亲这一辈的出生，逐渐热闹。然后在父亲这一辈的长大后，又逐渐开枝散叶，各自成家。再到我所代表的孙子辈的出生，看着我们长大，到后来我们离开。</p>
<p>从茫然，一点点到喧闹，再到冷清。</p>
<p>疫情之中，5 月的电话，匆忙中的机票，回家的错愕。</p>
<p>离开是相对的。</p>
<p>那天深夜，在锣声和唢呐声中，我为爷爷折着他教我折的元宝。</p>
<p>爷爷像睡着了一样。这个老人和一个时代共同落幕了。岁月易逝，一滴不剩。</p>
<p>爷爷上路那天，我抬着他，泪如雨下。</p>
<p>我们都长大了许多，可是我仍然学不会道别。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/29a0bec0/" data-id="cloj0dpuy000z2kw605849i9a" data-title="折旧" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-articles/一无所知" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/75b36508/" class="article-date">
  <time class="dt-published" datetime="2019-08-22T13:44:00.000Z" itemprop="datePublished">2019-08-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/article/">article</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/75b36508/">一无所知</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>“旧梦是好梦，虽然没有实现，但是我很高兴我有过这些梦。”<br>—— 《廊桥遗梦》</p>
</blockquote>
<p>7 月 27 日，大暑。夏天用高压锅闷着大地，胸口有些透不过气。</p>
<p>8 月初，阵雨转阴。北京的夏天竟然过的像南方绵雨下的秋天。</p>
<p>上半年工作压力很大，所有人都紧绷着神经。前些日子，集团组织了同事们去海边旅游放松，让紧绷的神经舒张片刻。</p>
<p>入夜以后，大家的情绪随着海水涨潮，在酒吧里杯觥交错。大家把酒言欢，兴致盎然。喝到后来某位哥们断片，认不出大家。</p>
<p>我不能喝酒，被问的多了，也会打趣的说：我见过太多的人醉了和断片，所以努力保持清醒，也许我害怕记忆会丢失吧。</p>
<p>这个世界太大，每天发生的事情太多。我们的认知在不断更新，记忆也在不断的流失。</p>
<p>前些日子，突然想听 suede 的 beautiful ones，记得已经收藏在 xx 云音乐的歌单里，然而搜索的时候才再也找不到。想起了不久前看过有人说 xx 云音乐会偷偷删除遗失在歌单角落里的歌曲。</p>
<p>我勃然大怒，心中又无比的恐慌，很快找回了这首歌 —— 如果我没有想起这首歌，也许它真的就从我的生命里消失了，仿佛从未来过。</p>
<p>或许我害怕记忆会走失吧。</p>
<p>去年发生了什么？昨天发生了什么？几个小时前发生了什么？几分钟前发生了什么？相机定格的笑容时心里想了什么？</p>
<p>我们总是在忘记，平凡的时刻会逐渐忘记，重要的时刻也会逐渐模糊，37.5°C 的感觉渐行渐远。</p>
<p>歌曲播放的伪随机算法，在 2000 首收藏的歌曲里只播放几百首我常听的歌曲，催化我的遗忘。</p>
<p>内容推荐算法只推荐那些我感兴趣的话题，让我只能渐渐只能在固定的话题里转圈，而忘记了我还了解过更多的世界。</p>
<p>城市在改变，让我在旧地重游的时候，再也找不到来时的路，记忆中的建筑逐渐模糊在脑海。</p>
<p>可是我们又总需要去面对和适应变化，甚至拥抱变化，让自己成长。为了追逐更好的自己而不断变化来训练自己，为了面对的压力而不断变化求存，还有别人的变化而对你产生了许多变化。</p>
<p>只是变化以后总会让人遗忘许多，尤其是一些重要的改变总会让人抱憾。</p>
<p>也许我们并不是害怕改变，而是害怕重要的东西突然离我们远去。更害怕那些应该被铭记的感觉被时间洗的泛白。</p>
<p>岁月悠长，我见过时间的力量，无论我们如何努力，在逆流中我们总是抓不住那些那些重要的东西，即便我们一次次复盘，然而却再也无法回头。</p>
<p>偶尔我们会想起听过的一首歌，再次翻出来并播放，却再也难以体会当初听到这首歌的感觉。</p>
<p>偶尔我们会回去走过的地方，却再也找不到最初放肆的自己。</p>
<p>偶尔有人闯入，又突然离开。</p>
<p>记忆是有重量的。有人说灵魂的重量是 21 克。可以承载的东西太少了。一生太长，容错率一天天降低，而记忆又总会溢出，有些背影随着时间逐渐消瘦，然后丢失。</p>
<p>所以，我也是一个不擅长挥手道别的人，每次挥手都不知所措。</p>
<p>有一天，我也会想起你，可是却再也无法想起关于你的细节 —— 你的眼睛，你的嘴角，你面部的线条，甚至你的发型，和你笑成二狗的样子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/75b36508/" data-id="cloj0dput00052kw6gpip3ira" data-title="一无所知" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/TypeScript中的多种import解义" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/688d139e/" class="article-date">
  <time class="dt-published" datetime="2019-02-20T09:45:00.000Z" itemprop="datePublished">2019-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/688d139e/">TypeScript 中的多种 import 解义</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JavaScript 中有多种 <code>export</code> 的方式，而 TypeScript 中针对这种情况做了多种 <code>import</code> 语法，最常见的就是 <code>import * as path from &#39;path&#39;</code> 这种。这篇文章主要来讲解 TypeScript 中不同的 import 具有什么意义。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<h2 id="从-export-说起"><a href="#从-export-说起" class="headerlink" title="从 export 说起"></a>从 export 说起</h2><p>有很多朋友都问过我关于 TypeScript 中不同 <code>import</code>  的含义，最典型的就是下面的 <code>import</code> 语法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不少人疑问这句代码究竟是什么意思，这里我们要先从 js 的 <code>export</code> 开始说。</p>
<p>首先，JavaScript 的模块化方案，在历史的演进中，有多种导出模块的方式：<code>exports</code>、<code>module.exports</code>、<code>export</code>、<code>export default</code>。</p>
<p>在 nodejs 中内置的模块遵循的都是 <a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS</a> 规范，语法为 <code>module.exports</code> 和 <code>exports</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块中的 exports 变量指向 module.exports</span></span><br><span class="line"><span class="comment">// 这篇文章不会深入讲解 module.exports 和 exports 的关系</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">site</span> = <span class="string">&#x27;https://tasaid.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">name</span> = <span class="string">&#x27;linkFly&#x27;</span></span><br></pre></td></tr></table></figure>


<p>例如 <code>nodejs</code> 内置的 <a target="_blank" rel="noopener" href="https://github.com/nodejs/node/blob/v8.0.0/lib/events.js#L29">events</a> 模块的源码：</p>
<p><img src="//static.tasaid.com/blogs/8035be46ea1725ebdaa8fce316bee8f6.png" alt="alt"></p>
<p>在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export">ECMAScript 6</a> 中又新增了语法 <code>export</code> 和 <code>export default</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> site = <span class="string">&#x27;https://tasaid.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;linkFly&#x27;</span></span><br></pre></td></tr></table></figure>


<p>到这里画风还比较正常，而大名鼎鼎的 JavaScript 转码编译器 babel 针对 ECMAScript 6 新增的 <code>export default</code> 语法，搞了个 <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-transform-es2015-modules-commonjs">babel-plugin-transform-es2015-modules-commonjs</a> 的转换插件，用于将 ECMAScript 6 转码为 CommonJs 规范的语法：</p>
<p>源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>编译后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">default</span> = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>到这里，我们看到有三种 <code>export</code> 默认值的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonjs</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel 转码</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">default</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-中的-import"><a href="#TypeScript-中的-import" class="headerlink" title="TypeScript 中的 import"></a>TypeScript 中的 import</h2><p>在 TypeScript 中，也有多种 <code>import</code> 的方式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonjs 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> xx <span class="keyword">from</span> <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 模块</span></span><br><span class="line"><span class="keyword">import</span> xx <span class="keyword">from</span> <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs 模块，类型声明为 export = xx</span></span><br><span class="line"><span class="keyword">import</span> xx = <span class="built_in">require</span>(<span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有类型声明，默认导入 any 类型</span></span><br><span class="line"><span class="keyword">const</span> xx = <span class="built_in">require</span>(<span class="string">&#x27;xx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在 <code>tsconfig.json</code> 中，<code>allowSyntheticDefaultImports</code> 会影响到 import 语法的类型检查规则，这个下面再说。</p>
<h3 id="import-as-xx-from-‘xx’"><a href="#import-as-xx-from-‘xx’" class="headerlink" title="import * as xx from ‘xx’"></a>import * as xx from ‘xx’</h3><p><code>import * as xx from &#39;xx&#39;</code> 的语法来一般都是用来导入使用 <code>module.exports</code> 导出的模块。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为 nodejs 中的模块大部分都是通过 <code>module.exports</code>、<code>exports.xx</code>  语法进行导出的。</p>
<h3 id="import-xx-from-‘xx’"><a href="#import-xx-from-‘xx’" class="headerlink" title="import xx from ‘xx’"></a>import xx from ‘xx’</h3><p>默认情况下，<code>import xx from &#39;xx&#39;</code> 的语法只适用于 ECMAScript 6 的 <code>export default</code> 导出：</p>
<p>模块 foo：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;https://tasaid.com&#x27;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 模块的导入：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./foo&#x27;</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>而前面我们说了，<code>babel</code> 会将 es6 的模块的 <code>export default </code> 语法编译为 <code>exports.default</code> 语法。</p>
<p>而 TypeScript 默认是不识别这种语法的，如果一个模块的导出是 <code>exports.default</code> 导出，如果使用 <code>import xx from &#39;xx&#39;</code> 的语法导入是会报错的。</p>
<p><img src="//static.tasaid.com/blogs/f1dcddc2b63a2f08cac178d2e577c4f9.png" alt="alt"></p>
<p>所以在 <code>tsconfig.json</code>  中，有个 <code>allowSyntheticDefaultImports</code> 选项，就是针对这种语法做兼容。</p>
<p>如果设定 <code>allowSyntheticDefaultImports</code> 为 <code>true</code>，则检测导入的模块是否是 ES6 模块，如果不是，则查找模块中是否有 <code>exports.default</code> 导出。</p>
<p>从而达到针对 <code>exports.default</code> 的兼容。</p>
<p><img src="//static.tasaid.com/blogs/43c0afaacd3bf0b8ef5b525257878654.png" alt="alt"></p>
<p>效果参见这个动画：</p>
<p><img src="//static.tasaid.com/blogs/15692299e770aefce2ce731ad2dbf50c.gif" alt="alt"></p>
<p>我个人是不推荐打开 <code>allowSyntheticDefaultImports</code> 选项的，一般情况下我采取的方式是将 deafult 重新命名：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="import-xx-require-‘xx’"><a href="#import-xx-require-‘xx’" class="headerlink" title="import xx &#x3D; require(‘xx’)"></a>import xx &#x3D; require(‘xx’)</h3><p><code>import xx = require(&#39;xx&#39;)</code>  是用来导入 commonjs 模块的库，特殊的地方在于这个库的类型声明是 <code>export = xx</code> 这种方式导出的：</p>
<p>foo.js 源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;https://tasaid.com&#x27;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foo.d.ts 类型声明文件源码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">export</span> = foo</span><br></pre></td></tr></table></figure>

<p>bar.ts 引用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/61b5ce0ab48d64bf27936ef294e269fb.png" alt="alt"></p>
<p>我在 《<a target="_blank" rel="noopener" href="https://tasaid.com/blog/20171102225101.html#module-exports">JavaScript 和 TypeScript 交叉口 —— 类型定义文件(*.d.ts)
</a>》中讲述过 TypeScript 类型声明文件对导入导出的影响。</p>
<h3 id="const-xx-require-‘xx’"><a href="#const-xx-require-‘xx’" class="headerlink" title="const xx &#x3D; require(‘xx’)"></a>const xx &#x3D; require(‘xx’)</h3><p>当一个模块没有类型声明文件的时候，可以使用 commonjs 原始的 <code>require()</code> 方式来导入模块，这样会默认该模块为 any。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们整体总结下，在 TypeScript 中，有多种 import 的方式，分别对应了 JavaScript 中不同的 export。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonjs 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> xx <span class="keyword">from</span> <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准 es6 模块</span></span><br><span class="line"><span class="keyword">import</span> xx <span class="keyword">from</span> <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs 模块，类型声明为 export = xx</span></span><br><span class="line"><span class="keyword">import</span> xx = <span class="built_in">require</span>(<span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有类型声明，默认导入 any 类型</span></span><br><span class="line"><span class="keyword">const</span> xx = <span class="built_in">require</span>(<span class="string">&#x27;xx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>针对 <code>babel</code> 编译出来的 <code>exports.default</code> 语法，ts 提供了 <code>allowSyntheticDefaultImports</code> 选项可以支持，只不过个人不太推荐。</p>
<p>个人建议将 <code>default</code> 重命名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>关于 TypeScript 中类型声明文件(*.d.ts) 对 import 和 export 的影响，可以参考我之前写的 《<a target="_blank" rel="noopener" href="https://tasaid.com/blog/20171102225101.html#import-dao-ru-he-export-dao-chu">JavaScript 和 TypeScript 交叉口 —— 类型定义文件
</a>》。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/issues/10895">Github - allowSyntheticDefaultImports should be the default?</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010426778">exports、module.exports和export、export default到底是咋回事</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/688d139e/" data-id="cloj0dpv6002k2kw6eu2c9lij" data-title="TypeScript 中的多种 import 解义" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/使用TypeScript编写一个完善包含测试、文档和持续集成的库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/cc45a7f4/" class="article-date">
  <time class="dt-published" datetime="2018-12-28T11:51:00.000Z" itemprop="datePublished">2018-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/cc45a7f4/">使用 TypeScript 编写一个完善包含测试、文档和持续集成的库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇文章主要是讲述如何使用 TypeScript 编写一个完善，包含测试、文档、持续集成的库，涵盖了编写整个库所需要的技术和工具，主要涵盖：</p>
<ol>
<li>项目目录骨架</li>
<li>TypeScript 配置</li>
<li>使用 jest 单元测试</li>
<li>使用 vuepress 编写文档</li>
<li>使用 github pages 部署文档</li>
<li>持续集成部署</li>
</ol>
<blockquote>
<p>前端开发 QQ 群：377786580<br>欢迎使用和了解滴滴金融出品的移动端组件库 <a target="_blank" rel="noopener" href="https://mand-mobile.github.io/">Mand-mobile</a>。</p>
</blockquote>
<p>为了迎合这篇文章，我编写了一个可以开箱即用的库模板：<a target="_blank" rel="noopener" href="https://github.com/linkFly6/ts-lib-basic">https://github.com/linkFly6/ts-lib-basic</a>。</p>
<p>里面集成了这篇文章所阐述的所有内容。</p>
<h2 id="初始化项目目录"><a href="#初始化项目目录" class="headerlink" title="初始化项目目录"></a>初始化项目目录</h2><p>先初始化项目目录，一般来说，<code>src</code> 放源码，<code>dist</code> 放编译后的代码，<code>tests</code> 放单元测试，所以先初始化好基础目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .vscode           <span class="comment"># vscode 配置</span></span><br><span class="line">│   └── launch.json   <span class="comment"># vscode 调试配置</span></span><br><span class="line">├── dist              <span class="comment"># 编译产出目录，编译后才有</span></span><br><span class="line">├── src               <span class="comment"># 源码</span></span><br><span class="line">├── tests             <span class="comment"># 单元测试</span></span><br><span class="line">├── .gitignore        <span class="comment"># git 忽略文件</span></span><br><span class="line">├── .npmrc            <span class="comment"># npm 配置</span></span><br><span class="line">├── .travis.yml       <span class="comment"># github 持续集成</span></span><br><span class="line">├── LICENSE           <span class="comment"># 开源协议</span></span><br><span class="line">├── README.md         <span class="comment"># README</span></span><br><span class="line">├── package-lock.json <span class="comment"># npm 锁定依赖</span></span><br><span class="line">├── package.json      <span class="comment"># npm</span></span><br><span class="line">├── tsconfig.json     <span class="comment"># typescript 配置</span></span><br><span class="line">└── tslint.json       <span class="comment"># tslint 校验</span></span><br></pre></td></tr></table></figure>

<p>先按照这个目录文件结构，然后我们会一步步填上内容。</p>
<p>通过 <code>npm init</code> 初始化一个 <code>npm</code> 配置：</p>
<p><img src="//static.tasaid.com/blogs/c5d7c541408de9243e3c2ddf3786681b.jpeg" alt="alt"></p>
<h2 id="初始化-TypeScript-相关工具"><a href="#初始化-TypeScript-相关工具" class="headerlink" title="初始化 TypeScript 相关工具"></a>初始化 TypeScript 相关工具</h2><p>既然包是基于 TypeScript 的，那么 TypeScript 工具必不可少。</p>
<h3 id="ts-node"><a href="#ts-node" class="headerlink" title="ts-node"></a>ts-node</h3><p>在开发中，可以使用 <a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">ts-node</a>（可以理解为可以直接执行 ts 文件的 node）来直接运行我们的 ts 代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev typescript</span><br><span class="line">npm i --save-dev ts-node</span><br></pre></td></tr></table></figure>

<p>如果是 node 应用，为了让 TypeScript 能够进行 node 类型推导，则需要安装 Node 对应的类型声明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev @types/node</span><br></pre></td></tr></table></figure>

<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p><a target="_blank" rel="noopener" href="https://tasaid.com/blog/20171011232938.html#tsconfig-json">tsconfig.json</a> 是 TypeScript 的配置文件，这里提供一份可供参考是配置，置于项目根目录：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>, <span class="comment">// 模块配置</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否默认禁用 any</span></span><br><span class="line">    <span class="comment">// &quot;removeComments&quot;: true, // 是否移除注释</span></span><br><span class="line">    <span class="string">&quot;types&quot;</span>: [ <span class="comment">// 默认引入的类型声明</span></span><br><span class="line">      <span class="string">&quot;node&quot;</span>, <span class="comment">// 默认引入 node 的类型声明</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>, <span class="comment">// 工作根目录</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// ~/ 指向 server/types，types 目录下都是 types 文件，所以不会编译产出</span></span><br><span class="line">      <span class="string">&quot;~/*&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;./types/*&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es6&quot;</span>, <span class="comment">// 编译目标</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>, <span class="comment">// 输出目录</span></span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否自动创建类型声明</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 此配置生效范围</span></span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tslint-json"><a href="#tslint-json" class="headerlink" title="tslint.json"></a>tslint.json</h3><p><a target="_blank" rel="noopener" href="https://palantir.github.io/tslint/">tslint</a> 类似 <code>eslint</code>，是 TypeScript 中的代码风格约束工具。</p>
<p>关于 lint，个人方面比较倾向于非强制性的，所以只在 vscode 中安装了扩展 <code>tslint</code>，这样 vscode 会根据项目根目录配置的 <code>tslint.json</code> 标出不符合规范的信息。</p>
<p>这里有一份推荐配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;defaultSeverity&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;tslint:recommended&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;jsRules&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-line-length&quot;</span>: [</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="number">140</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 禁止内置原始类型</span></span><br><span class="line">    <span class="string">&quot;ban-types&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 禁止给参数赋值</span></span><br><span class="line">    <span class="string">&quot;no-parameter-reassignment&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 禁止空接口</span></span><br><span class="line">    <span class="string">&quot;no-empty-interface&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 显示类型代码就不需要再加类型声明了</span></span><br><span class="line">    <span class="string">&quot;no-inferrable-types&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 不允许使用内部模块</span></span><br><span class="line">    <span class="string">&quot;no-internal-module&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 不允许在变量赋值之外使用常量数值。如果未指定允许值的列表, 则默认情况下允许-1、0和1 =&gt; 乱七八糟的数字会让人混淆</span></span><br><span class="line">    <span class="comment">// &quot;no-magic-numbers&quot;: [true],</span></span><br><span class="line">    <span class="comment">// 不允许使用内部 &#x27;modules&#x27; 和 &#x27;namespace&#x27;</span></span><br><span class="line">    <span class="string">&quot;no-namespace&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 非空断言，强制使用 == null 之类的断言</span></span><br><span class="line">    <span class="comment">// &quot;no-non-null-assertion&quot;: true</span></span><br><span class="line">    <span class="comment">// 禁止 /// &lt;reference path=&gt;，直接用 import 即可</span></span><br><span class="line">    <span class="string">&quot;no-reference&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 require，应该使用 import foo = require(&#x27;foo&#x27;)</span></span><br><span class="line">    <span class="string">&quot;no-var-requires&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// import 的顺序按照字母表</span></span><br><span class="line">    <span class="string">&quot;ordered-imports&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 对象属性声明按照字母表</span></span><br><span class="line">    <span class="string">&quot;object-literal-sort-keys&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// // 结束语句后的分号</span></span><br><span class="line">    <span class="string">&quot;semicolon&quot;</span>: [</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;always&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 字符串强制单引号</span></span><br><span class="line">    <span class="string">&quot;quotemark&quot;</span>: [</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;single&quot;</span>,</span><br><span class="line">      <span class="string">&quot;jsx-double&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 禁止 arguments.callee</span></span><br><span class="line">    <span class="string">&quot;no-arg&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// if 语句的单行不用括号，多行用括号</span></span><br><span class="line">    <span class="string">&quot;curly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否强制使用箭头函数，禁止匿名函数</span></span><br><span class="line">    <span class="string">&quot;only-arrow-functions&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否禁止多个空行</span></span><br><span class="line">    <span class="string">&quot;no-consecutive-blank-lines&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 在函数括号前要求或不允许空格</span></span><br><span class="line">    <span class="string">&quot;space-before-function-paren&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 箭头函数的参数使用括号</span></span><br><span class="line">    <span class="string">&quot;arrow-parens&quot;</span>: [</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;ban-single-arg-parens&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 不固定变量类型</span></span><br><span class="line">    <span class="string">&quot;no-shadowed-variable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 行尾多余的空格</span></span><br><span class="line">    <span class="string">&quot;no-trailing-whitespace&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// == 和 ===</span></span><br><span class="line">    <span class="string">&quot;triple-equals&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 禁止一些位运算符</span></span><br><span class="line">    <span class="string">&quot;no-bitwise&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 禁止 console</span></span><br><span class="line">    <span class="string">&quot;no-console&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 检查变量名</span></span><br><span class="line">    <span class="string">&quot;variable-name&quot;</span>: [</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;ban-keywords&quot;</span></span><br><span class="line">      <span class="comment">// &quot;check-format&quot;,</span></span><br><span class="line">      <span class="comment">// &quot;allow-leading-underscore&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 一行声明变量表达式</span></span><br><span class="line">    <span class="string">&quot;one-variable-per-declaration&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 允许在一个文件里定义多个 class</span></span><br><span class="line">    <span class="string">&quot;max-classes-per-file&quot;</span>: [</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 判断表达式 fn &amp;&amp; fn()</span></span><br><span class="line">    <span class="string">&quot;no-unused-expression&quot;</span>: [</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;allow-fast-null-checks&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 空函数</span></span><br><span class="line">    <span class="string">&quot;no-empty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// forin 是否必须包含 hasOwnProperty 判断</span></span><br><span class="line">    <span class="string">&quot;forin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;no-debugger&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 强制要求必须要声明类型</span></span><br><span class="line">    <span class="string">&quot;typedef&quot;</span>: [</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;rulesDirectory&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;./src&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p><code>package-lock.json</code> 是 npm 5 之后引入的，为了解决 npm 过去使用的 <code>package.json</code> 版本依赖太宽松的问题。</p>
<p>比如说 <code>package.json</code> 中依赖了包 <code>mand-mobile</code>，使用了最常用的插入依赖（<code>^</code>）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;mand-mobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.16.4&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>假设自己项目在上线阶段， <code>mand-mobile</code> 更新到了 <code>mand-mobile@4.17.0</code>，而刚好 <code>mand-mobile@4.17.0</code> 又不小心出现了一个新 bug 会导致页面脚本错误。这时候上线安装依赖的时候，由于 <code>package.json</code> 和 <code>^</code> 约束太宽松，就会导致 <code>mand-mobile@4.17.0</code> 被安装，从而导致上线出问题。</p>
<p><code>package-lock.json</code> 就是为了解决这个问题，通过 npm 安装包的时候，会检测本地是否有 <code>package-lock.json</code>。</p>
<ul>
<li>如果没有 <code>package-lock.json</code>，就在安装包的时候将当前包依赖的详细信息（包括子级依赖）都写入生成 <code>package-lock.json</code>。</li>
<li>如果有 <code>package-lock.json</code>，则根据 <code>package.json</code>，参考 <code>pacakge-lock.json</code> 来安装包依赖。来保证依赖稳定。</li>
</ul>
<p>本质上 <code>ppackage-lock.json</code> 的作用类似于 node_modules 包依赖的快照。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>一个合格的库应该包含完整的单元测试。这里我们使用 <a target="_blank" rel="noopener" href="https://jestjs.io/">jest</a> 对应的 TypeScript 版本：<a target="_blank" rel="noopener" href="https://kulshekhar.github.io/ts-jest/">ts-jest</a>。</p>
<h3 id="ts-jest"><a href="#ts-jest" class="headerlink" title="ts-jest"></a>ts-jest</h3><p><a target="_blank" rel="noopener" href="https://kulshekhar.github.io/ts-jest/">ts-jest</a> 是 <a target="_blank" rel="noopener" href="https://jestjs.io/">jest</a> 的 TypeScript 支持版，API 和 <code>jest</code> 是一样的，它能够直接运行 <code>.ts</code> 为后缀的单元测试文件。</p>
<p>安装 <code>ts-jest</code> 和对应的类型声明文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev jest  <span class="comment">#ts-jest 依赖 jest</span></span><br><span class="line">npm i --save-dev ts-jest</span><br><span class="line">npm i --save-dev @types/jest</span><br></pre></td></tr></table></figure>

<p>在 <code>package.json</code> 中加入 <code>jest</code> 配置和 <code>npm run test</code> 的脚本：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-app&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jest --verbose&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tests&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;transform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;^.+\\.tsx?$&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ts-jest&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;testRegex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(/__tests__/.*|(\\.|/)(test|spec))\\.tsx?$&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;moduleFileExtensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;tsx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;jsx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;json&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;node&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这时候就可以基于 <code>jest</code> 编写单元测试了。在 <code>tests/</code> 目录下加入 <code>example.test.ts</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isArrayLike &#125; <span class="keyword">from</span> <span class="string">&#x27;../src&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;my-app:isArrayLike&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="string">&#x27;isArrayLike(): true&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">expect</span>(</span><br><span class="line">      <span class="title function_">isArrayLike</span>([]),</span><br><span class="line">    ).<span class="title function_">toBe</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">test</span>(<span class="string">&#x27;isArrayLike(): false&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">expect</span>(</span><br><span class="line">      <span class="title function_">isArrayLike</span>(&#123;&#125;),</span><br><span class="line">    ).<span class="title function_">toBe</span>(<span class="literal">false</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>npm run test</code> 即可看到单元测试结果。</p>
<p><img src="//static.tasaid.com/blogs/613cf346b1c34a5f7c282f751d4ba45a.jpeg" alt="alt"></p>
<h3 id="express-测试"><a href="#express-测试" class="headerlink" title="express 测试"></a>express 测试</h3><p>如果要测试 <code>express</code>&#x2F;<code>koa</code> 之类的 web 应用框架程序，则可以使用 tj 大神的 <a target="_blank" rel="noopener" href="https://github.com/visionmedia/supertest">supertest</a>。</p>
<p>安装对应的包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev supertest</span><br><span class="line">npm i --save-dev @types/supertest</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于测试 express、koa 等 web 应用框架的工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> request <span class="keyword">from</span> <span class="string">&#x27;supertest&#x27;</span></span><br><span class="line"><span class="keyword">import</span> middleware <span class="keyword">from</span> <span class="string">&#x27;../src&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;my-app:basic&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="string">&#x27;locals&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">    app.<span class="title function_">use</span>(middleware)</span><br><span class="line">    app.<span class="title function_">get</span>(<span class="string">&#x27;/example&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">send</span>(&#123; <span class="attr">code</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 使用 supertest 进行测试</span></span><br><span class="line">    <span class="title function_">request</span>(app).<span class="title function_">get</span>(<span class="string">&#x27;/example&#x27;</span>).<span class="title function_">expect</span>(<span class="number">200</span>, &#123; <span class="attr">code</span>: <span class="number">0</span> &#125;, done)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p><a target="_blank" rel="noopener" href="https://github.com/visionmedia/debug">debug</a> 也是 tj 大神编写的一个库，用于在应用程序中输出 <code>debug</code> 信息，用于调试工具库，著名的库大部分都采用该库进行 debug 支持。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i --save debug</span><br><span class="line">npm i --save-dev @types/debug</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> d <span class="keyword">from</span> <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="title function_">d</span>(<span class="string">`my-app:basic`</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">debug</span>(<span class="string">&#x27;debug info&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在启动应用程序的时候，只需要在环境变量中注入 DEBUG 即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=my-app* node app.js</span><br><span class="line"></span><br><span class="line">DEBUG=my-app* ts-node app.ts</span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/f16f80293ca0f819e9c53e283d899b54.jpeg" alt="alt"></p>
<h3 id="vscode-基于-ts-node-调试"><a href="#vscode-基于-ts-node-调试" class="headerlink" title="vscode 基于 ts-node 调试"></a>vscode 基于 ts-node 调试</h3><p>在 <code>.vscode/launch.json</code> 中可以配置基于 <code>ts-node</code> 的调试：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">  <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">  <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;启动程序&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// 基于 ts-node 调试</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/node_modules/ts-node/dist/bin.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-P&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceRoot&#125;/tests/tsconfig.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceRoot&#125;/tests/app.ts&quot;</span><span class="punctuation">,</span> <span class="comment">// 入口文件</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="//static.tasaid.com/blogs/9e9e56a434cfb1a4bf6085fba12cd4a3.png" alt="alt"></p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档方面，简陋一点的，可以直接使用 README，也可以用 <a target="_blank" rel="noopener" href="https://www.gitbook.com/?t=1">gitbook</a>。不过我个人方便比较推荐 <a target="_blank" rel="noopener" href="https://vuepress.vuejs.org/zh/">vuepress</a>。</p>
<p>远程托管文档方面，要么自建服务器，要么直接托管到 Github 的 Pages。</p>
<h3 id="使用-vuepress-编写文档"><a href="#使用-vuepress-编写文档" class="headerlink" title="使用 vuepress 编写文档"></a>使用 vuepress 编写文档</h3><p>个人比较倾向于使用 <a target="_blank" rel="noopener" href="https://vuepress.vuejs.org/zh/">vuepress</a> 编写文档，是因为里面扩展 Markdown 扩展了许多丰富实用的语法，以及菜单结构的强大可配置。</p>
<p>这里我们讨论的是在项目中集成文档。</p>
<ol>
<li>在项目根目录新建目录 <code>/docs</code></li>
<li><code>npm i --save-dev vuepress</code></li>
<li>在项目的 <code>package.json</code> 中加入脚本</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;docs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vuepress dev docs&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;docs:build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vuepress build docs&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>/docs</code> 新增文件 <code>README.md</code>，写入以下内容：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">home: true</span><br><span class="line">actionText: 开始使用 →</span><br><span class="line">actionLink: /readme</span><br><span class="line">footer: MIT Licensed | Copyright © 2018-present linkFly</span><br><span class="line">features:</span><br><span class="line"><span class="bullet">-</span> title: 快速</span><br><span class="line">  details: 快速创建库</span><br><span class="line"><span class="bullet">-</span> title: 集成</span><br><span class="line">  details: 集成单元测试和自动化 doc 部署</span><br><span class="line"><span class="bullet">-</span> title: TypeScript</span><br><span class="line"><span class="section">  details: TypeScript 支持</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">集成了基础工具的，使用 TypeScript 快速编写一个应用库</span><br></pre></td></tr></table></figure>

<p>然后执行结合我们刚才配置的命令，执行 <code>npm run docs</code>，终端 shell 会输出 <code>vuepress</code> 启动的服务地址：</p>
<p><img src="//static.tasaid.com/blogs/addf678e00cc07686aceb389a6c7b580.jpeg" alt="alt"></p>
<p>访问地址，即可看到文档页面：</p>
<p><img src="//static.tasaid.com/blogs/7d98390649f013562323f0dbe3b4db2f.jpeg" alt="alt"></p>
<h3 id="使用-github-pages-托管文档"><a href="#使用-github-pages-托管文档" class="headerlink" title="使用 github pages 托管文档"></a>使用 github pages 托管文档</h3><p><a target="_blank" rel="noopener" href="https://pages.github.com/">github pages</a> 是 Github 提供的一个免费的页面托管服务，我们可以将 vuepress 编译出来的文档托管到上面。</p>
<p>Github Pages 服务和 Github 已经打通，可以从项目的 <code>/docs</code> 目录自动部署，这也就是我们为什么要在项目里新建 <code>/docs</code> 目录的原因。</p>
<p>首先，我们将项目中 <code>pageage.json</code> 的脚本进行更新：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;docs:build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vuepress build docs &amp;&amp; cp -rf ./docs/.vuepress/dist/* ./docs &amp;&amp; rm -r ./docs/.vuepress/dist&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这段脚本的大体意思就是先使用 <code>vuepress</code> 构建产出文档的 HTML 文件（在 <code>/docs/.vuepress/dist</code> 目录下），然后将 <code>dist</code> 目录移动到 <code>docs/</code> 目录下，因为 Github Pages 在识别 <code>docs/</code> 的时候只能识别 <code>docs/index.html</code>。</p>
<p>执行 <code>npm run docs:build</code>。</p>
<p>将本地的项目 push 到 Github 以后，打开该项目的 <code>Setting</code>：</p>
<p><img src="//static.tasaid.com/blogs/9501c183d0057f06b56428bba878a247.jpeg" alt="alt"></p>
<p>在 Github Pages 配置项选择 <code>docs/</code> 文件夹：</p>
<p><img src="//static.tasaid.com/blogs/eff41f4099bdcf8d96b8a4ab724bebbf.jpeg" alt="alt"></p>
<p>然后访问 <code>https://&lt;USERNAME or GROUP&gt;.gitlab.io/&lt;REPO&gt;/</code> 即可看到自动部署的文档。例如：<a target="_blank" rel="noopener" href="https://linkfly6.github.io/ts-lib-basic/">https://linkfly6.github.io/ts-lib-basic/</a>。</p>
<h2 id="使用持续集成服务-travis-ci"><a href="#使用持续集成服务-travis-ci" class="headerlink" title="使用持续集成服务 travis-ci"></a>使用持续集成服务 travis-ci</h2><p><a target="_blank" rel="noopener" href="https://travis-ci.org/">travis-ci</a> 是一个持续集成服务，它可以用来自动部署和构建 Github 上的项目。</p>
<p>我们可以集成我们的单元测试。</p>
<p>在项目根目录加入 <code>.travis.yml</code>，在 master 分支进行提交的时候自动运行 <code>npm run test</code> 命令（npm run test 命令配置参见 <a href="#ts-jest">ts-jest</a> 章节）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>打开 <a target="_blank" rel="noopener" href="https://travis-ci.org/">https://travis-ci.org/</a> 进行注册或登录。新增接入的项目：</p>
<p><img src="//static.tasaid.com/blogs/12e34ff40f415204b4300de47e338c18.jpeg" alt="alt"></p>
<p>选择要打开持续集成的项目：</p>
<p><img src="//static.tasaid.com/blogs/6717f581e962c3e3e871e397bef467fc.jpeg" alt="alt"></p>
<p>然后我们更新文档或代码，提交代码到 Github。</p>
<p>稍等大概几十秒，就可以在 travis-ci 里面看到自己的单元测试任务：</p>
<p><img src="//static.tasaid.com/blogs/bbf320cd5ee9c71a718643e9375c8677.jpeg" alt="alt"></p>
<p>最后，在测试完毕的情况下，在 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> 进行注册。</p>
<p>在 npm 的源是官方的（<code>npm config set registry https://registry.npmjs.org/</code>）情况下，执行 <code>npm login</code> 登录 npm 以后，<code>npm publish</code> 发布包即可。</p>
<p>最后，为了迎合这篇文章，我编写了一个可以开箱即用的库模板：<a target="_blank" rel="noopener" href="https://github.com/linkFly6/ts-lib-basic">https://github.com/linkFly6/ts-lib-basic</a>。</p>
<p>里面集成了这篇文章所阐述的所有内容。</p>
<blockquote>
<p>前端开发 QQ 群：377786580<br>欢迎使用和了解金融出品的移动端组件库 <a target="_blank" rel="noopener" href="https://mand-mobile.github.io/">Mand-mobile</a>。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/cc45a7f4/" data-id="cloj0dpve00492kw6e6xchgov" data-title="使用 TypeScript 编写一个完善包含测试、文档和持续集成的库" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-articles/远方的再见" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/27b651dd/" class="article-date">
  <time class="dt-published" datetime="2018-11-20T07:47:00.000Z" itemprop="datePublished">2018-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/article/">article</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/27b651dd/">远方的再见</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>十一回家，趁着中午阳光慵懒，乘车和许久未见的朋友去会面。</p>
<p>朋友开了一家奶茶店，刚开门，店里只有他一个人在忙，很多原材料都没有准备好。恰好来了一些客人，点了几杯奶茶，我在一旁看着朋友悠闲的准备着奶茶。</p>
<p>等朋友忙完出来，我说在这么一个三线城市，开家小店，真的很悠闲。朋友跟我说他本身就不求功利，对钱也没有太大的兴趣，只想过自己想要的简单生活。</p>
<p>我们也聊到过去的许多事，讨论曾经关联在一起的小伙伴，今天过的怎么样。</p>
<p>我想，是不是也有一些人也在远方，讨论着我。他们会讨论我的如今过的怎么样，成为了什么样的人。</p>
<p>自己是否成为了那个曾经想要成为的人。</p>
<p>时过境迁，我们身上逐渐背负了越来越多的包袱，已经无力再去追寻更多的自由。</p>
<p>就好像一首歌，还没有仔细听，就已经躺在歌单的下一页。时间越来越快，感觉自己的时间越来越少。</p>
<p>人这一生大约会遇到 80000 人。</p>
<p>有人逐渐断线，有人逐渐走来。</p>
<p>有人成为目标，激励我们去追寻。</p>
<p>有人成为伙伴，陪伴成长。</p>
<p>有人砰然心动，最后擦肩而过。</p>
<p>有些人伫立在字里行间，而我停笔太久。</p>
<p>总能想起那个阳光慵懒的下午，老师在课堂上讲着沉闷的课文，窗外有风，同学们昏昏沉沉，同桌在和坐在远方的同学传递着小纸条，那个让人心跳加速的姑娘在隔壁班的隔壁。未来无法被数学课本里的公式推导，所以我们一脸迷茫的看着窗外的树叶飘摇。</p>
<p>那时候的远方，是未知的兴奋和迷茫。</p>
<p>我去远方只是为了和你道声再见。</p>
<blockquote>
<p>这篇文章在 10 月已经写完，当时没有找到合适的音乐来描述内心，于是搁浅。直到 11 月听到了这首歌。<br> 背景封面是 《楚门的世界(The Truman Show)》</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/27b651dd/" data-id="cloj0dpv3001x2kw6fj8u8u70" data-title="远方的再见" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-articles/羔羊在号叫" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/6c3047ef/" class="article-date">
  <time class="dt-published" datetime="2018-09-04T13:30:00.000Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/article/">article</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/6c3047ef/">羔羊在号叫</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>汉尼拔：现在我会聆听。在你父亲被害之后，你成了孤儿，你只有 10 岁。你去住在表亲的蒙大拿农场里，接着呢？</p>
<p>克拉丽丝：一天早晨，我只是出走了。</p>
<p>汉尼拔：没那么简单，克拉丽丝。是什么让你出走，什么时候发生的？</p>
<p>克拉丽丝：很早，天还没亮。</p>
<p>汉尼拔：于是有事发生让你醒来，不是吗？是梦还是别的？</p>
<p>克拉丽丝：我听到奇特的声音。</p>
<p>汉尼拔：是什么？</p>
<p>克拉丽丝：是尖叫，一种尖叫，像孩子般的声音。</p>
<p>汉尼拔：你做什么了？</p>
<p>克拉丽丝：我下了楼梯走到外面，蹑手蹑脚的来到牲口棚。里面的场景太吓人了。</p>
<p>汉尼拔：你看到了什么？</p>
<p>克拉丽丝：羔羊们在号叫。</p>
<p>汉尼拔：他们在屠宰春羔？</p>
<p>汉尼拔：你逃跑了？</p>
<p>克拉丽丝：不。起初我想放掉它们。我打开了门，可它们却不动，只是困惑的站在那，它们不想跑。</p>
<p>汉尼拔：但是你可以，不是吗？</p>
<p>克拉丽丝：是的，我带走了一只羔羊，拼尽全力的逃跑。</p>
<p>汉尼拔：克拉丽丝，你要去哪？</p>
<p>克拉丽丝：我不知道，我没有食物和水，天气很冷，我想如果我可以哪怕只救出来一只，可是……他太重了。当我搭上治安官的车，我还没跑出几英里。农场主很生气，他把我送进波兹曼的路德教会孤儿院，我再没看到过那家农场。</p>
<p>汉尼拔：那你的羊羔呢，克拉丽丝？</p>
<hr>
<p>当羔羊安静下来，你是否听到心灵最暗处的呐喊和低语？</p>
<hr>
<blockquote>
<p>—— 摘自电影《沉默的羔羊(The Silence of the Lambs)》</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/6c3047ef/" data-id="cloj0dpv1001h2kw6gczv3s9b" data-title="羔羊在号叫" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-blogs/Web前端解决方案指南-社区的演变" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/b984666f/" class="article-date">
  <time class="dt-published" datetime="2018-09-03T12:41:36.000Z" itemprop="datePublished">2018-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech/">tech</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/b984666f/">Web 前端解决方案指南 - 社区的演变</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今日的 web 和几年前的 web 已经演变了很多，多变而又复杂。从过去传统局限在前后一体，逐渐进化到今天技术繁多，一直延伸到 webapp，SSR 甚至发展到客户端。</p>
<p><img src="//static.tasaid.com/blogs/9e38ba77fe99427f17ffb9642cc794bd.png" alt="alt"></p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>
<h2 id="蛮荒时代"><a href="#蛮荒时代" class="headerlink" title="蛮荒时代"></a>蛮荒时代</h2><p>早在几年我刚入行的时候，jQuery 风头正盛 —— “你可以不会 JavaScript，但你必须要会 jQuery”。那个时候 AMD 和 CMD 模块规范在社区里摩擦着火花。那时候没有 web 前后端分离的概念，前端的代码依附在后端项目中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── release</span><br><span class="line">├── src 		<span class="comment"># 后端相关</span></span><br><span class="line">│   ├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │    ├── com</span><br><span class="line">│   ├── resources</span><br><span class="line">├── bin</span><br><span class="line">├── WebRoot 	<span class="comment"># 前端相关</span></span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── js</span><br><span class="line">│   ├── META-INF</span><br><span class="line">│   ├── WEB-INF</span><br><span class="line">│   │    ├── lib</span><br><span class="line">│   └── index.jsp</span><br></pre></td></tr></table></figure>

<p>过去项目里前端资源依附下后端项目下，这么设计是因为当初前端远没有今天这么复杂，属于项目中的一小部分，所以依附下传统业务项目上。当时在大型 web 架构中（前后端），微服务、模块分离、业务分离的概念还没有今天这般清晰。</p>
<p>另外就是那时候的大部分都是后端工程师也包揽了前端的事情，所以放在传统后端项目中理所当然。web 前端工程师也只是近几年才有的岗位。</p>
<p>如此带来的劣势也很明显，就是前端很依赖后端项目，在今天看来，让一个前端选手打开后端项目，并且从头到尾撸一遍逻辑。尤其再配合后端 web 框架情侣搭配的 JSP&#x2F;Razor&#x2F;ASP .NET 服务端渲染，酸爽的气息扑面而来。</p>
<p>这些前后端混在一起的状态十分痛苦，整个社区迫切需要一种解决方案，而 Nodejs 的兴起，使得这些无处安放的解决方案有了一个最佳平台。</p>
<h2 id="社区的演变"><a href="#社区的演变" class="headerlink" title="社区的演变"></a>社区的演变</h2><p>Node 横空出世，带来了属于 web 前端的生态圈的朝阳。它主要带来了两个革命性的东西：</p>
<ul>
<li>npm 包管理</li>
<li>一个脱离了浏览器的运行环境</li>
</ul>
<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>当 Brendan Eich 仅花了 10 天开发 JavaScript 的时候，并没有考虑到它会发展到今天这样壮大 —— JavaScript 缺少良好的包管理方案。</p>
<p><img src="//static.tasaid.com/blogs/e46300089abc80da3752b9dbaee186d2.jpeg" alt="alt"></p>
<p>nodejs 带来了 <code>npm</code> 包管理，那些无处安放的工具类库终于有了一个平台，大家纷纷将自己封装的工具、库放到 npm 上，然后其他人也可以引入这个包，生态由此建立。而因为 npm 的设计缺陷加上社区的活跃。</p>
<p>当然，npm 上包的质量和数量逐渐形成一种新的历史包袱，例如 2016 年在 npm 上发生的 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41694868">left-pad 事件</a> 也给了 npm 社区一个新的警示。</p>
<p>在现代 web 应用中，应该根据项目的需要，优先利用起 npm 作为包管理方案，结合优秀的模块管理方案，抛弃过去 引入 <code>&lt;script /&gt;</code> 引入包的方式。</p>
<h3 id="百花齐放的编译工具"><a href="#百花齐放的编译工具" class="headerlink" title="百花齐放的编译工具"></a>百花齐放的编译工具</h3><p>随着 Nodejs 的到来，Nodejs  是基于 Chrome V8 引擎打造的一个 JavaScript 运行环境，可以让 js 不再局限于浏览器中。</p>
<p>而 JavaScript 的规范 ECMAScript 也配合时代的发展迎来快速更新。我们有了新的需求：</p>
<ul>
<li>更新的语言规范编写的代码，需要运行在各种老旧的浏览器上（通过 <code>babel</code> 等）</li>
<li>增强现有技术的新技术（例如 <code>React JSX/TypeScript</code>）</li>
</ul>
<p>于是前端也走上了其他大型语言的老路 —— 编译。</p>
<p>正是 Nodejs 提供了强大平台的，让编译工具开始百花齐放，webpack、rollup、parceljs、gulp、grunt 等编译工具逐渐流行，“配置工程师” 这个耐人寻味的名词逐渐活跃在前端圈。</p>
<p>真怀念过去写个 js 然后 <code>&lt;script /&gt;</code> 引入的简单日子…</p>
<p><img src="//static.tasaid.com/blogs/3a3f3804e54297024bc32d061087c73b.png" alt="alt"></p>
<h3 id="node-web-server"><a href="#node-web-server" class="headerlink" title="node web server"></a>node web server</h3><p>Nodejs 拔高整个行业的水平是无疑的，随着 Nodejs 的热门，以 Nodejs 为后端的主力军逐渐开始出现，“nodejs 工程师” 的字眼也开始出现在岗位招聘当中。Nodejs 可以是编译工具的平台，也可以是 node web server —— 一个完善的后端服务。</p>
<p>以 express 和 koa 为核心的 web server，配合数据库的操作，让前端产生了更多的想象力。</p>
<p><img src="//static.tasaid.com/blogs/50c7689bfb86072929435f54dcd75d61.png" alt="alt"></p>
<p>Nodejs web server 的出现让前端的技术范围延伸到了后端，从 client 一路 “编写 JavaScript” 到 server。</p>
<p>在现代 web 前端架构中，Nodejs 扮演着重要的角色，它可以在编译阶段为编译工具提供平台，在此之上继而编写自己的自动化工具。也可以在前后端分离的场景中，建立一个中间服务，编写前后端的胶水。</p>
<p>更可以独立成为 web server，连接整个前后端。</p>
<h3 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h3><p>前端社区的壮大充满了想象力，有耀眼的巨星 <code>React-Native</code> 试着将 web 的技术融入到移动端 native，也有部分人将 web 前端的技术延伸到了传统的桌面端 —— <a target="_blank" rel="noopener" href="https://electronjs.org/">Electron</a> 由此而生。</p>
<p>Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建桌面应用程序。</p>
<p><img src="//static.tasaid.com/blogs/b7517c1a7450395b11d13ae6576542fc.png" alt="alt"></p>
<blockquote>
<p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。</p>
</blockquote>
<p>Electron 具有跨平台的特性，和 Web 相关技术融合，以及简单精致的 API 设计。</p>
<p><img src="//static.tasaid.com/blogs/1d90378c693f13e345a55bf1f8861625.png" alt="alt"></p>
<blockquote>
<p>Any application that can be written in JavaScript, willeventually be written in JavaScript.<br>任何可以使用 JavaScript 编写的程序，最终都会使用 JavaScript 编写<br>—— Jeff Atwood</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>前面讲解了很多关于 web 前端的历史，是希望所有人都可以意识到，前端发展到了今天，已经不是简单 HTML&#x2F;css&#x2F;js 就可以概括的东西，它的应用场景也越来越丰富，项目复杂程序今非昔比，而如何保证一个长期可维护的项目本身就需要一些思考加以提炼精华。</p>
<p>理想的解决方案，首当其冲，应该有一套迎合当前环境的架构方案。</p>
<p>架构是一套将现有技术归并，并打出组合拳，融入了设计思想，也以一套规范形成整个项目风格的骨架。 </p>
<p>架构的是规范的基础，也是规范的壁垒，同样它也是规范的最后一道防线。</p>
<p>在架构一个项目的时候，应该考虑优先以下几个特性：可维护性，可扩展性，规范化约束和风格。</p>
<p>顺便我们可以提一下现在前端圈的脚手架。脚手架脚手架模板本质上也是架构，一种通用，结合了最佳实践的架构。</p>
<p>脚手架致力于最佳实践，并留出足够的可扩展性，以便基于业务型架构，延伸出迎合业务的最佳实践。</p>
<p>当然，解决方案包含了架构、设计思想、编码规范、工程化和基础工具设施等，甚至与部署方式都有关的。架构只是其中相对比较重要的一个环节而已。</p>
<p>在良好的解决方案中，应该包含几个关键点：</p>
<h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>优先保证可维护性，这是我们追求良好解决方案的核心。不能项目完成后，在业务没有大幅度调动的情况下，项目支撑不到半年就变的难以维护或不可维护，随着时间推进技术债会积累的越来越深。</p>
<p>从立项开始，目录结构，文件名，甚至构建方式都影响着后续的项目可维护性，所以在项目立项之初的每一步都必须经过深思熟虑。</p>
<p>例如下面的目录结构就没有考虑到 <code>components</code> 和 <code>module</code> 的区别，数据如何流向，逻辑放哪里等问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── app</span><br><span class="line">│   ├── main.js</span><br><span class="line">├── assets</span><br><span class="line">│   ├── config</span><br><span class="line">│   ├── fonts</span><br><span class="line">│   ├── imgs</span><br><span class="line">│   ├── libs</span><br><span class="line">│   └── tools</span><br><span class="line">├── components</span><br><span class="line">│   ├── common</span><br><span class="line">│   └── partial</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure>

<p>项目可维护性是一个值得严阵以待的问题。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>在项目架构方面，需要具有可扩展性。在真实的业务场景中，被产品方向、产品需求、技术氛围、公司工具等环境影响的因素非常多，保持架构的可扩展性同样非常重要。</p>
<p>但是每次扩展不应该是随便找个地方写个目录就可以了，久而久之会因为被随意扩展，再次导致项目可维护性越来越低，所以可扩展性是相对的，在现有的架构上可以平滑、可控的扩展，而不应该被随意扩展。</p>
<p>很多项目就有这种情况，刚开始的目录规范定的很好，随着需求的变多随意扩展目录，越到后来目录越来越多，每个目录都概念模糊。</p>
<p>对于这个问题的解决，个人崇尚的方案是 code review，约定和规范永远没有良好的 code review 来的粗暴且有效。同样 code review 能够在及时发现问题，在可控的时间内把控好整个项目的规范和约束。</p>
<p>其次，可扩展考虑不仅仅只是目录，代码、业务、甚至服务器集群，都要保留可扩展性。</p>
<p>在代码层面，需要保留统一的入口和出口处理。</p>
<ul>
<li>统一管理的 HTTP 请求方法，统一的 HTTP 结果处理</li>
<li>统一管理的逻辑层入口</li>
<li>统一管理的数据流向</li>
<li>统一管理的状态管理（例如用户状态机）</li>
<li>统一管理的 BaseComponents&#x2F;BasePage</li>
<li>统一管理的 BaseModel</li>
</ul>
<p>做这些统一为了为了后续可以在统一的入口处做扩展，例如 HTTP 所有请求都要加一个参数贯穿全局的参数，HTTP 请求结果都需要新增一个相同的特殊判断等。</p>
<h3 id="合理的服务规划"><a href="#合理的服务规划" class="headerlink" title="合理的服务规划"></a>合理的服务规划</h3><p>在团队中，迎合业务需求的项目，需要有明确的服务资源规划。</p>
<p>是依赖现有服务资源的，例如资源是放到自己的服务器，还是托管到 CDN 上，代码在基于公司还是其他第三方构建平台，服务是否部署 Nodejs，部署是和后端服务在一起还是分离？</p>
<p>这些问题都会影响着项目如何进行自动工程化，如何部署等代码之外的，这在项目架构中也应该合理的调度结合项目现有资源。</p>
<p>例如我们会自行编写一些脚本，自动启动测试服务，上线之前编译的时候，连接公司的编译平台，然后再通过公司的线上平台上 docker，上线过程中自动将资源上传到 CDN。</p>
<p>这一整套的工程都应该是在项目架构中解决，而不能把问题抛给开发人员，尽可能的让开发人员能够快速沉浸写码即可。</p>
<p>同时要需要确定项目兼容性，列出项目兼容列表。尤其是移动端，可以列出市面上 Top 10 的移动设备作为基本兼容面，在后续统计产品访问量的时候更新兼容设备列表。</p>
<h3 id="规范化约束和风格"><a href="#规范化约束和风格" class="headerlink" title="规范化约束和风格"></a>规范化约束和风格</h3><p>根据团队风格确定整个项目的编码风格，使用 <a target="_blank" rel="noopener" href="http://eslint.cn/">eslint</a> 或 <a target="_blank" rel="noopener" href="https://palantir.github.io/tslint/">tslint</a> 确定编码风格，开发中强制开启编译检查。</p>
<p>在这里，我个人仍然觉得，任何的代码风格和约束，都比不上 code review。在团队风格搭建初期，尤其 code review 至关重要。</p>
<h3 id="合理的通用性"><a href="#合理的通用性" class="headerlink" title="合理的通用性"></a>合理的通用性</h3><p>这里的之所以用 “合理” 来表述，是用来反驳一昧追求通用性的设计。从一开始的设计中强行抽离业务、抽离环境，自己造轮子，过分追求通用性，对项目的危害更大。</p>
<p>通用性应该是在真实实践过后，根据遇到的场景逐渐抽离出来的通用性，而不是一开始就刻意设计会通用，阻碍业务之后，死板着一个理念 “不行我不能掺和业务，这设计一定得通用”，从而起到反面效果。</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>除了根据功能分层之外，在业务逻辑上也需要有合理的分层规划，前端并不应该仅仅只是简单的拿到数据做展现，要针对不同的业务场景，在搭建项目初期就针对业务做逻辑分层，并保留业务层的逻辑。</p>
<p>推荐的分层逻辑：</p>
<ul>
<li>逻辑分层 - 按照业务逻辑进行分层切割</li>
<li>UI 分层 - 按照页面的数据展现，聚合和切割 UI，包括 UI 数据的分层</li>
<li>服务分层 - 服务分层包含了对数据和接口的服务分层整理</li>
</ul>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>前端的本质是操作数据，数据输入到服务器，输出到页面中，是一个数据流转的过程。数据是通过单向数据流(flux)，还是双向数据绑定。</p>
<p>这里不应该过分追求某一数据流向的形式，而是针对业务场景，在合适的场景，做合适的事情。</p>
<h3 id="可配置"><a href="#可配置" class="headerlink" title="可配置"></a>可配置</h3><p>无论是业务逻辑还是业务运营位，项目的细节（例如服务端口），做到适度可配置化，从而让项目的可重用性更高。</p>
<h3 id="组件和模块"><a href="#组件和模块" class="headerlink" title="组件和模块"></a>组件和模块</h3><p>这是一个老生常谈的问题，复杂的业务必然有自己的业务模型和 UI 模型，对应衍生出组件（Component）和模块（Module）的概念：</p>
<ul>
<li>组件 - 强调复用，核心关注 UI</li>
<li>模块 - 强调职责，它是一个业务行为的打包</li>
</ul>
<h3 id="渐进式优化"><a href="#渐进式优化" class="headerlink" title="渐进式优化"></a>渐进式优化</h3><p>和上面提到的 “反驳一昧追求通用性的设计” 相似，任何架构和设计，都不是在起初都尽善尽美。我们应该在项目需求渐进中，逐步优化现有解决方案。</p>
<p>尤其需要注意的是，尽可能避免重复造轮子，先做分内事，再横向扩展。虽然前端er 们都是一群皂动不安的人群，但在业务之中应该理清先后顺序，不能一昧追求自己技术的快感从而影响了业务稳定的本质。</p>
<p>在这里个人推崇的思想是：先做好架构，再做完整的解决方案。</p>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>自动化可以很好的解放生产力，我们应该学会偷懒，为了让自己偷懒而做好自动化。任何繁琐的手动操作都应该去尝试自动化，在这一领域就需要自己丰富的横向知识面，这里自动化尤其关注这几点：</p>
<ol>
<li>一键打包</li>
<li>一键启动开发环境</li>
<li>一键部署测试环境</li>
<li>一键部署生产环境</li>
<li>一键上传部署资源</li>
</ol>
<p>当然这应该是一个现代优秀解决方案的基本面，在实际的应用场景中，应该结合公司，或者开源社区的各种持续集成平台，汇聚各大工具的优势而简化我们后续部署等重复而又繁琐的工作。</p>
<h3 id="明确的指标"><a href="#明确的指标" class="headerlink" title="明确的指标"></a>明确的指标</h3><p>所有的工作应该是可以被量化的，优化了什么环节，必然会来优化的成果，从一开始就应该对成果有一个量化的指标，例如：</p>
<ul>
<li>页面加载时间 &lt;&#x3D; 1.2s </li>
<li>code review &gt;&#x3D; 80%</li>
<li>typescript 类型补充 &gt;&#x3D; 90%</li>
<li>包大小 &lt;&#x3D; 1mb</li>
<li>部署时间 &lt;&#x3D; 10ms</li>
<li>组件和模块数量</li>
<li>重复代码在 &lt;&#x3D; 20 份（或 100 行）</li>
<li>http 请求数 &lt;&#x3D; 40</li>
<li>store 数据仓储 &lt;&#x3D; 20</li>
</ul>
<p>还有很多可量化指标，这些可量化指标用于最终验收成果，或者在不断的 code review 中精进代码和团队风格有着决定性的作用。</p>
<p>当然，还有 KPI….</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章主要给大家讲解了 JavaScript 历史的演变，和社区对于优秀解决方案的探索，并且指出了一些设计思路。</p>
<p>《Web 前端解决方案指南》在一个系列文章，在后续的文章中我们会逐渐探索现代 Web 应用中的一些常见的 Web 前端架构形式和对应的解决方案，分别包括 Webapp、分片 Web、前端服务（Webapp + node）、electron 等。欢迎关注我的博客 <a target="_blank" rel="noopener" href="https://tasaid.com/">听说</a> 。</p>
<blockquote>
<p>前端开发 QQ 群：377786580</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/b984666f/" data-id="cloj0dpv6002n2kw6bs6516c4" data-title="Web 前端解决方案指南 - 社区的演变" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-articles/有一天与某一天" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/f14f80f1/" class="article-date">
  <time class="dt-published" datetime="2018-06-21T05:32:00.000Z" itemprop="datePublished">2018-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/article/">article</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/f14f80f1/">有一天与某一天</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有一天我会看到小学最不羁的男生安静地经营着一家咖啡店</p>
<p>有一天我会看到初中最文静的女生老练地吸着烟</p>
<p>有一天我会看到高中最玩世不恭的男生手忙脚乱地给孩子换着尿布</p>
<p>有一天我会看到曾经最叛逆的人用最保守的方式教育孩子</p>
<p>有一天我会看到曾经吐槽官僚主义的人穿着西装革履宣读政府公文</p>
<p>有一天我会看到曾经发誓改革制度的人懒散地坐在公务员办公室草草过完一生</p>
<p>有一天我会看到曾经高呼分数是屁的人会因不及格暴打自己的孩子</p>
<p>有一天我会看到初中就在一起的情侣在越洋电话后从此不再见面</p>
<p>有一天我会看到我们终于都成了与想象中截然不同的人</p>
<p>某一天</p>
<p>你发现最痞的同学做了老师</p>
<p>最老实的同学成了痞子</p>
<p>最花心的学姐做起了全职妈妈</p>
<p>最美好的初恋做起了酒吧前台</p>
<p>最抠门的穷小子当上了酒店老板</p>
<p>最慷慨的朋友在建筑队里干活</p>
<p>当你发现曾经最好的兄弟聚在一块，他颤颤微微地敬你一杯酒还加了一个“您”字</p>
<p>当你听说曾经与你立下海誓山盟的女孩成了两个孩子的母亲</p>
<p>你会不会突然觉得，这个世界莫名其妙？</p>
<p>谁也不知道下一步会发生什么。</p>
<p>多年以后，我们，都会变成什么模样？</p>
<p>—— 摘自网络</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/f14f80f1/" data-id="cloj0dpuz00152kw67ihpdro6" data-title="有一天与某一天" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/article/">article</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tech/">tech</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Said/" rel="tag">Said</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTTPS/" style="font-size: 12.5px;">HTTPS</a> <a href="/tags/JavaScript/" style="font-size: 17.5px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Said/" style="font-size: 15px;">Said</a> <a href="/tags/TypeScript/" style="font-size: 20px;">TypeScript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/cfe1281/">一段职业生涯的总结</a>
          </li>
        
          <li>
            <a href="/posts/8127ee4b/">一段旅程</a>
          </li>
        
          <li>
            <a href="/posts/29a0bec0/">折旧</a>
          </li>
        
          <li>
            <a href="/posts/75b36508/">一无所知</a>
          </li>
        
          <li>
            <a href="/posts/688d139e/">TypeScript 中的多种 import 解义</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>